// This code was autogenerated with `dbus-codegen-rust `, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_tree as tree;

pub trait OrgA11yAtspiAccessible {
    fn get_child_at_index(&self, index: i32) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn get_children(&self) -> Result<Vec<(String, dbus::Path<'static>)>, tree::MethodErr>;
    fn get_index_in_parent(&self) -> Result<i32, tree::MethodErr>;
    fn get_relation_set(&self) -> Result<Vec<(u32, Vec<(String, dbus::Path<'static>)>)>, tree::MethodErr>;
    fn get_role(&self) -> Result<u32, tree::MethodErr>;
    fn get_role_name(&self) -> Result<String, tree::MethodErr>;
    fn get_localized_role_name(&self) -> Result<String, tree::MethodErr>;
    fn get_state(&self) -> Result<Vec<u32>, tree::MethodErr>;
    fn get_attributes(&self) -> Result<::std::collections::HashMap<String, String>, tree::MethodErr>;
    fn get_application(&self) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn get_interfaces(&self) -> Result<Vec<String>, tree::MethodErr>;
    fn name(&self) -> Result<String, tree::MethodErr>;
    fn description(&self) -> Result<String, tree::MethodErr>;
    fn parent(&self) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn child_count(&self) -> Result<i32, tree::MethodErr>;
    fn locale(&self) -> Result<String, tree::MethodErr>;
    fn accessible_id(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_a11y_atspi_accessible_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiAccessible,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Accessible", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_child_at_index(index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetChildAtIndex", Default::default(), h);
    let m = m.in_arg(("index", "i"));
    let m = m.out_arg(("", "(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_children()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetChildren", Default::default(), h);
    let m = m.out_arg(("", "a(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_index_in_parent()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetIndexInParent", Default::default(), h);
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_relation_set()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRelationSet", Default::default(), h);
    let m = m.out_arg(("", "a(ua(so))"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_role()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRole", Default::default(), h);
    let m = m.out_arg(("", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_role_name()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRoleName", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_localized_role_name()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetLocalizedRoleName", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_state()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetState", Default::default(), h);
    let m = m.out_arg(("", "au"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_attributes()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAttributes", Default::default(), h);
    let m = m.out_arg(("", "a{ss}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_application()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetApplication", Default::default(), h);
    let m = m.out_arg(("", "(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_interfaces()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetInterfaces", Default::default(), h);
    let m = m.out_arg(("", "as"));
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("Name", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.name()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Description", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.description()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<(&str, dbus::Path), _>("Parent", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.parent()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("ChildCount", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.child_count()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Locale", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.locale()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("AccessibleId", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.accessible_id()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiAction {
    fn get_description(&self, index: i32) -> Result<String, tree::MethodErr>;
    fn get_name(&self, index: i32) -> Result<String, tree::MethodErr>;
    fn get_localized_name(&self, index: i32) -> Result<String, tree::MethodErr>;
    fn get_key_binding(&self, index: i32) -> Result<String, tree::MethodErr>;
    fn get_actions(&self) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn do_action(&self, index: i32) -> Result<bool, tree::MethodErr>;
    fn nactions(&self) -> Result<i32, tree::MethodErr>;
}

pub fn org_a11y_atspi_action_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiAction,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Action", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_description(index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetDescription", Default::default(), h);
    let m = m.in_arg(("index", "i"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_name(index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetName", Default::default(), h);
    let m = m.in_arg(("index", "i"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_localized_name(index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetLocalizedName", Default::default(), h);
    let m = m.in_arg(("index", "i"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_key_binding(index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetKeyBinding", Default::default(), h);
    let m = m.in_arg(("index", "i"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_actions()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetActions", Default::default(), h);
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.do_action(index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("DoAction", Default::default(), h);
    let m = m.in_arg(("index", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let p = factory.property::<i32, _>("NActions", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.nactions()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiApplication {
    fn get_locale(&self, lctype: u32) -> Result<String, tree::MethodErr>;
    fn register_event_listener(&self, event: &str) -> Result<(), tree::MethodErr>;
    fn deregister_event_listener(&self, event: &str) -> Result<(), tree::MethodErr>;
    fn toolkit_name(&self) -> Result<String, tree::MethodErr>;
    fn version(&self) -> Result<String, tree::MethodErr>;
    fn atspi_version(&self) -> Result<String, tree::MethodErr>;
    fn id(&self) -> Result<i32, tree::MethodErr>;
    fn set_id(&self, value: i32) -> Result<(), tree::MethodErr>;
}

pub fn org_a11y_atspi_application_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiApplication,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Application", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let lctype: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_locale(lctype)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetLocale", Default::default(), h);
    let m = m.in_arg(("lctype", "u"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let event: &str = i.read()?;
        let d = fclone(minfo);
        d.register_event_listener(event)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterEventListener", Default::default(), h);
    let m = m.in_arg(("event", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let event: &str = i.read()?;
        let d = fclone(minfo);
        d.deregister_event_listener(event)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("DeregisterEventListener", Default::default(), h);
    let m = m.in_arg(("event", "s"));
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("ToolkitName", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.toolkit_name()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Version", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.version()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("AtspiVersion", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.atspi_version()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("Id", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.id()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_id(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiCollection {
    fn get_matches(&self, rule: (Vec<i32>, i32, ::std::collections::HashMap<&str, &str>, i32, Vec<i32>, i32, Vec<&str>, i32, bool), sortby: u32, count: i32, traverse: bool) -> Result<Vec<(String, dbus::Path<'static>)>, tree::MethodErr>;
    fn get_matches_to(&self, current_object: dbus::Path, rule: (Vec<i32>, i32, ::std::collections::HashMap<&str, &str>, i32, Vec<i32>, i32, Vec<&str>, i32, bool), sortby: u32, tree: u32, limit_scope: bool, count: i32, traverse: bool) -> Result<Vec<(String, dbus::Path<'static>)>, tree::MethodErr>;
    fn get_matches_from(&self, current_object: dbus::Path, rule: (Vec<i32>, i32, ::std::collections::HashMap<&str, &str>, i32, Vec<i32>, i32, Vec<&str>, i32, bool), sortby: u32, tree: u32, count: i32, traverse: bool) -> Result<Vec<(String, dbus::Path<'static>)>, tree::MethodErr>;
    fn get_active_descendant(&self) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
}

pub fn org_a11y_atspi_collection_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgA11yAtspiCollection,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Collection", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let rule: (Vec<i32>, i32, ::std::collections::HashMap<&str, &str>, i32, Vec<i32>, i32, Vec<&str>, i32, bool) = i.read()?;
        let sortby: u32 = i.read()?;
        let count: i32 = i.read()?;
        let traverse: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_matches(rule, sortby, count, traverse)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetMatches", Default::default(), h);
    let m = m.in_arg(("rule", "(aiia{ss}iaiiasib)"));
    let m = m.in_arg(("sortby", "u"));
    let m = m.in_arg(("count", "i"));
    let m = m.in_arg(("traverse", "b"));
    let m = m.out_arg(("", "a(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let current_object: dbus::Path = i.read()?;
        let rule: (Vec<i32>, i32, ::std::collections::HashMap<&str, &str>, i32, Vec<i32>, i32, Vec<&str>, i32, bool) = i.read()?;
        let sortby: u32 = i.read()?;
        let tree: u32 = i.read()?;
        let limit_scope: bool = i.read()?;
        let count: i32 = i.read()?;
        let traverse: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_matches_to(current_object, rule, sortby, tree, limit_scope, count, traverse)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetMatchesTo", Default::default(), h);
    let m = m.in_arg(("current_object", "o"));
    let m = m.in_arg(("rule", "(aiia{ss}iaiiasib)"));
    let m = m.in_arg(("sortby", "u"));
    let m = m.in_arg(("tree", "u"));
    let m = m.in_arg(("limit_scope", "b"));
    let m = m.in_arg(("count", "i"));
    let m = m.in_arg(("traverse", "b"));
    let m = m.out_arg(("", "a(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let current_object: dbus::Path = i.read()?;
        let rule: (Vec<i32>, i32, ::std::collections::HashMap<&str, &str>, i32, Vec<i32>, i32, Vec<&str>, i32, bool) = i.read()?;
        let sortby: u32 = i.read()?;
        let tree: u32 = i.read()?;
        let count: i32 = i.read()?;
        let traverse: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_matches_from(current_object, rule, sortby, tree, count, traverse)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetMatchesFrom", Default::default(), h);
    let m = m.in_arg(("current_object", "o"));
    let m = m.in_arg(("rule", "(aiia{ss}iaiiasib)"));
    let m = m.in_arg(("sortby", "u"));
    let m = m.in_arg(("tree", "u"));
    let m = m.in_arg(("count", "i"));
    let m = m.in_arg(("traverse", "b"));
    let m = m.out_arg(("", "a(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_active_descendant()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetActiveDescendant", Default::default(), h);
    let m = m.out_arg(("", "(so)"));
    let i = i.add_m(m);
    i
}

pub trait OrgA11yAtspiComponent {
    fn contains(&self, x_: i32, y_: i32, coord_type: u32) -> Result<bool, tree::MethodErr>;
    fn get_accessible_at_point(&self, x_: i32, y_: i32, coord_type: u32) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn get_extents(&self, coord_type: u32) -> Result<(i32, i32, i32, i32), tree::MethodErr>;
    fn get_position(&self, coord_type: u32) -> Result<(i32, i32), tree::MethodErr>;
    fn get_size(&self) -> Result<(i32, i32), tree::MethodErr>;
    fn get_layer(&self) -> Result<u32, tree::MethodErr>;
    fn get_mdizorder(&self) -> Result<i16, tree::MethodErr>;
    fn grab_focus(&self) -> Result<bool, tree::MethodErr>;
    fn get_alpha(&self) -> Result<f64, tree::MethodErr>;
    fn set_extents(&self, x_: i32, y_: i32, width: i32, height: i32, coord_type: u32) -> Result<bool, tree::MethodErr>;
    fn set_position(&self, x_: i32, y_: i32, coord_type: u32) -> Result<bool, tree::MethodErr>;
    fn set_size(&self, width: i32, height: i32) -> Result<bool, tree::MethodErr>;
    fn scroll_to(&self, type_: u32) -> Result<bool, tree::MethodErr>;
    fn scroll_to_point(&self, type_: u32, x_: i32, y_: i32) -> Result<bool, tree::MethodErr>;
}

pub fn org_a11y_atspi_component_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgA11yAtspiComponent,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Component", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.contains(x_, y_, coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("Contains", Default::default(), h);
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let m = m.in_arg(("coord_type", "u"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_accessible_at_point(x_, y_, coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAccessibleAtPoint", Default::default(), h);
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let m = m.in_arg(("coord_type", "u"));
    let m = m.out_arg(("", "(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_extents(coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetExtents", Default::default(), h);
    let m = m.in_arg(("coord_type", "u"));
    let m = m.out_arg(("", "(iiii)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let (x_, y_) = d.get_position(coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(x_);
        let rm = rm.append1(y_);
        Ok(vec!(rm))
    };
    let m = factory.method("GetPosition", Default::default(), h);
    let m = m.in_arg(("coord_type", "u"));
    let m = m.out_arg(("x", "i"));
    let m = m.out_arg(("y", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let (width, height) = d.get_size()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(width);
        let rm = rm.append1(height);
        Ok(vec!(rm))
    };
    let m = factory.method("GetSize", Default::default(), h);
    let m = m.out_arg(("width", "i"));
    let m = m.out_arg(("height", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_layer()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetLayer", Default::default(), h);
    let m = m.out_arg(("", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_mdizorder()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetMDIZOrder", Default::default(), h);
    let m = m.out_arg(("", "n"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.grab_focus()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GrabFocus", Default::default(), h);
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_alpha()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAlpha", Default::default(), h);
    let m = m.out_arg(("", "d"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let width: i32 = i.read()?;
        let height: i32 = i.read()?;
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.set_extents(x_, y_, width, height, coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("SetExtents", Default::default(), h);
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let m = m.in_arg(("width", "i"));
    let m = m.in_arg(("height", "i"));
    let m = m.in_arg(("coord_type", "u"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.set_position(x_, y_, coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("SetPosition", Default::default(), h);
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let m = m.in_arg(("coord_type", "u"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let width: i32 = i.read()?;
        let height: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.set_size(width, height)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("SetSize", Default::default(), h);
    let m = m.in_arg(("width", "i"));
    let m = m.in_arg(("height", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let type_: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.scroll_to(type_)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("ScrollTo", Default::default(), h);
    let m = m.in_arg(("type", "u"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let type_: u32 = i.read()?;
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.scroll_to_point(type_, x_, y_)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("ScrollToPoint", Default::default(), h);
    let m = m.in_arg(("type", "u"));
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);
    i
}

pub trait OrgA11yAtspiDocument {
    fn get_locale(&self) -> Result<String, tree::MethodErr>;
    fn get_attribute_value(&self, attributename: &str) -> Result<String, tree::MethodErr>;
    fn get_attributes(&self) -> Result<::std::collections::HashMap<String, String>, tree::MethodErr>;
    fn current_page_number(&self) -> Result<i32, tree::MethodErr>;
    fn page_count(&self) -> Result<i32, tree::MethodErr>;
}

pub fn org_a11y_atspi_document_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiDocument,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Document", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_locale()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetLocale", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let attributename: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_attribute_value(attributename)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAttributeValue", Default::default(), h);
    let m = m.in_arg(("attributename", "s"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_attributes()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAttributes", Default::default(), h);
    let m = m.out_arg(("", "a{ss}"));
    let i = i.add_m(m);

    let p = factory.property::<i32, _>("CurrentPageNumber", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.current_page_number()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("PageCount", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.page_count()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiHypertext {
    fn get_nlinks(&self) -> Result<i32, tree::MethodErr>;
    fn get_link(&self, link_index: i32) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn get_link_index(&self, character_index: i32) -> Result<i32, tree::MethodErr>;
}

pub fn org_a11y_atspi_hypertext_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgA11yAtspiHypertext,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Hypertext", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_nlinks()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetNLinks", Default::default(), h);
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let link_index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_link(link_index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetLink", Default::default(), h);
    let m = m.in_arg(("linkIndex", "i"));
    let m = m.out_arg(("", "(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let character_index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_link_index(character_index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetLinkIndex", Default::default(), h);
    let m = m.in_arg(("characterIndex", "i"));
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);
    i
}

pub trait OrgA11yAtspiHyperlink {
    fn get_object(&self, i_: i32) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn get_uri(&self, i_: i32) -> Result<String, tree::MethodErr>;
    fn is_valid(&self) -> Result<bool, tree::MethodErr>;
    fn nanchors(&self) -> Result<i16, tree::MethodErr>;
    fn start_index(&self) -> Result<i32, tree::MethodErr>;
    fn end_index(&self) -> Result<i32, tree::MethodErr>;
}

pub fn org_a11y_atspi_hyperlink_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiHyperlink,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Hyperlink", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let i_: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_object(i_)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetObject", Default::default(), h);
    let m = m.in_arg(("i", "i"));
    let m = m.out_arg(("", "(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let i_: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_uri(i_)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetURI", Default::default(), h);
    let m = m.in_arg(("i", "i"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.is_valid()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("IsValid", Default::default(), h);
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let p = factory.property::<i16, _>("NAnchors", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.nanchors()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("StartIndex", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.start_index()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("EndIndex", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.end_index()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiImage {
    fn get_image_extents(&self, coord_type: u32) -> Result<(i32, i32, i32, i32), tree::MethodErr>;
    fn get_image_position(&self, coord_type: u32) -> Result<(i32, i32), tree::MethodErr>;
    fn get_image_size(&self) -> Result<(i32, i32), tree::MethodErr>;
    fn image_description(&self) -> Result<String, tree::MethodErr>;
    fn image_locale(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_a11y_atspi_image_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiImage,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Image", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_image_extents(coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetImageExtents", Default::default(), h);
    let m = m.in_arg(("coordType", "u"));
    let m = m.out_arg(("", "(iiii)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let (x_, y_) = d.get_image_position(coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(x_);
        let rm = rm.append1(y_);
        Ok(vec!(rm))
    };
    let m = factory.method("GetImagePosition", Default::default(), h);
    let m = m.in_arg(("coordType", "u"));
    let m = m.out_arg(("x", "i"));
    let m = m.out_arg(("y", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let (width, height) = d.get_image_size()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(width);
        let rm = rm.append1(height);
        Ok(vec!(rm))
    };
    let m = factory.method("GetImageSize", Default::default(), h);
    let m = m.out_arg(("width", "i"));
    let m = m.out_arg(("height", "i"));
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("ImageDescription", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.image_description()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("ImageLocale", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.image_locale()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiSelection {
    fn get_selected_child(&self, selected_child_index: i32) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn select_child(&self, child_index: i32) -> Result<bool, tree::MethodErr>;
    fn deselect_selected_child(&self, selected_child_index: i32) -> Result<bool, tree::MethodErr>;
    fn is_child_selected(&self, child_index: i32) -> Result<bool, tree::MethodErr>;
    fn select_all(&self) -> Result<bool, tree::MethodErr>;
    fn clear_selection(&self) -> Result<bool, tree::MethodErr>;
    fn deselect_child(&self, child_index: i32) -> Result<bool, tree::MethodErr>;
    fn nselected_children(&self) -> Result<i32, tree::MethodErr>;
}

pub fn org_a11y_atspi_selection_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiSelection,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Selection", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let selected_child_index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_selected_child(selected_child_index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetSelectedChild", Default::default(), h);
    let m = m.in_arg(("selectedChildIndex", "i"));
    let m = m.out_arg(("", "(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let child_index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.select_child(child_index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("SelectChild", Default::default(), h);
    let m = m.in_arg(("childIndex", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let selected_child_index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.deselect_selected_child(selected_child_index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("DeselectSelectedChild", Default::default(), h);
    let m = m.in_arg(("selectedChildIndex", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let child_index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.is_child_selected(child_index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("IsChildSelected", Default::default(), h);
    let m = m.in_arg(("childIndex", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.select_all()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("SelectAll", Default::default(), h);
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.clear_selection()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("ClearSelection", Default::default(), h);
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let child_index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.deselect_child(child_index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("DeselectChild", Default::default(), h);
    let m = m.in_arg(("childIndex", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let p = factory.property::<i32, _>("NSelectedChildren", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.nselected_children()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiTable {
    fn get_accessible_at(&self, row: i32, column: i32) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn get_index_at(&self, row: i32, column: i32) -> Result<i32, tree::MethodErr>;
    fn get_row_at_index(&self, index: i32) -> Result<i32, tree::MethodErr>;
    fn get_column_at_index(&self, index: i32) -> Result<i32, tree::MethodErr>;
    fn get_row_description(&self, row: i32) -> Result<String, tree::MethodErr>;
    fn get_column_description(&self, column: i32) -> Result<String, tree::MethodErr>;
    fn get_row_extent_at(&self, row: i32, column: i32) -> Result<i32, tree::MethodErr>;
    fn get_column_extent_at(&self, row: i32, column: i32) -> Result<i32, tree::MethodErr>;
    fn get_row_header(&self, row: i32) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn get_column_header(&self, column: i32) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn get_selected_rows(&self) -> Result<Vec<i32>, tree::MethodErr>;
    fn get_selected_columns(&self) -> Result<Vec<i32>, tree::MethodErr>;
    fn is_row_selected(&self, row: i32) -> Result<bool, tree::MethodErr>;
    fn is_column_selected(&self, column: i32) -> Result<bool, tree::MethodErr>;
    fn is_selected(&self, row: i32, column: i32) -> Result<bool, tree::MethodErr>;
    fn add_row_selection(&self, row: i32) -> Result<bool, tree::MethodErr>;
    fn add_column_selection(&self, column: i32) -> Result<bool, tree::MethodErr>;
    fn remove_row_selection(&self, row: i32) -> Result<bool, tree::MethodErr>;
    fn remove_column_selection(&self, column: i32) -> Result<bool, tree::MethodErr>;
    fn get_row_column_extents_at_index(&self, index: i32) -> Result<(bool, i32, i32, i32, i32, bool), tree::MethodErr>;
    fn nrows(&self) -> Result<i32, tree::MethodErr>;
    fn ncolumns(&self) -> Result<i32, tree::MethodErr>;
    fn caption(&self) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn summary(&self) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
    fn nselected_rows(&self) -> Result<i32, tree::MethodErr>;
    fn nselected_columns(&self) -> Result<i32, tree::MethodErr>;
}

pub fn org_a11y_atspi_table_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiTable,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Table", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let row: i32 = i.read()?;
        let column: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_accessible_at(row, column)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAccessibleAt", Default::default(), h);
    let m = m.in_arg(("row", "i"));
    let m = m.in_arg(("column", "i"));
    let m = m.out_arg(("", "(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let row: i32 = i.read()?;
        let column: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_index_at(row, column)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetIndexAt", Default::default(), h);
    let m = m.in_arg(("row", "i"));
    let m = m.in_arg(("column", "i"));
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_row_at_index(index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRowAtIndex", Default::default(), h);
    let m = m.in_arg(("index", "i"));
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let index: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_column_at_index(index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetColumnAtIndex", Default::default(), h);
    let m = m.in_arg(("index", "i"));
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let row: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_row_description(row)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRowDescription", Default::default(), h);
    let m = m.in_arg(("row", "i"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let column: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_column_description(column)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetColumnDescription", Default::default(), h);
    let m = m.in_arg(("column", "i"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let row: i32 = i.read()?;
        let column: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_row_extent_at(row, column)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRowExtentAt", Default::default(), h);
    let m = m.in_arg(("row", "i"));
    let m = m.in_arg(("column", "i"));
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let row: i32 = i.read()?;
        let column: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_column_extent_at(row, column)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetColumnExtentAt", Default::default(), h);
    let m = m.in_arg(("row", "i"));
    let m = m.in_arg(("column", "i"));
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let row: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_row_header(row)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRowHeader", Default::default(), h);
    let m = m.in_arg(("row", "i"));
    let m = m.out_arg(("", "(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let column: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_column_header(column)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetColumnHeader", Default::default(), h);
    let m = m.in_arg(("column", "i"));
    let m = m.out_arg(("", "(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_selected_rows()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetSelectedRows", Default::default(), h);
    let m = m.out_arg(("", "ai"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_selected_columns()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetSelectedColumns", Default::default(), h);
    let m = m.out_arg(("", "ai"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let row: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.is_row_selected(row)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("IsRowSelected", Default::default(), h);
    let m = m.in_arg(("row", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let column: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.is_column_selected(column)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("IsColumnSelected", Default::default(), h);
    let m = m.in_arg(("column", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let row: i32 = i.read()?;
        let column: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.is_selected(row, column)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("IsSelected", Default::default(), h);
    let m = m.in_arg(("row", "i"));
    let m = m.in_arg(("column", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let row: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.add_row_selection(row)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("AddRowSelection", Default::default(), h);
    let m = m.in_arg(("row", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let column: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.add_column_selection(column)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("AddColumnSelection", Default::default(), h);
    let m = m.in_arg(("column", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let row: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.remove_row_selection(row)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("RemoveRowSelection", Default::default(), h);
    let m = m.in_arg(("row", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let column: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.remove_column_selection(column)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("RemoveColumnSelection", Default::default(), h);
    let m = m.in_arg(("column", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let index: i32 = i.read()?;
        let d = fclone(minfo);
        let (arg0, row, col, row_extents, col_extents, is_selected) = d.get_row_column_extents_at_index(index)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(row);
        let rm = rm.append1(col);
        let rm = rm.append1(row_extents);
        let rm = rm.append1(col_extents);
        let rm = rm.append1(is_selected);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRowColumnExtentsAtIndex", Default::default(), h);
    let m = m.in_arg(("index", "i"));
    let m = m.out_arg(("", "b"));
    let m = m.out_arg(("row", "i"));
    let m = m.out_arg(("col", "i"));
    let m = m.out_arg(("row_extents", "i"));
    let m = m.out_arg(("col_extents", "i"));
    let m = m.out_arg(("is_selected", "b"));
    let i = i.add_m(m);

    let p = factory.property::<i32, _>("NRows", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.nrows()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("NColumns", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.ncolumns()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<(&str, dbus::Path), _>("Caption", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.caption()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<(&str, dbus::Path), _>("Summary", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.summary()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("NSelectedRows", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.nselected_rows()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("NSelectedColumns", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.nselected_columns()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiTableCell {
    fn get_row_column_span(&self) -> Result<(bool, i32, i32, i32, i32), tree::MethodErr>;
    fn column_span(&self) -> Result<i32, tree::MethodErr>;
    fn position(&self) -> Result<(i32, i32), tree::MethodErr>;
    fn row_span(&self) -> Result<i32, tree::MethodErr>;
    fn table(&self) -> Result<(String, dbus::Path<'static>), tree::MethodErr>;
}

pub fn org_a11y_atspi_table_cell_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiTableCell,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.TableCell", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let (arg0, row, col, row_extents, col_extents) = d.get_row_column_span()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(row);
        let rm = rm.append1(col);
        let rm = rm.append1(row_extents);
        let rm = rm.append1(col_extents);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRowColumnSpan", Default::default(), h);
    let m = m.out_arg(("", "b"));
    let m = m.out_arg(("row", "i"));
    let m = m.out_arg(("col", "i"));
    let m = m.out_arg(("row_extents", "i"));
    let m = m.out_arg(("col_extents", "i"));
    let i = i.add_m(m);

    let p = factory.property::<i32, _>("ColumnSpan", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.column_span()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<(i32, i32), _>("Position", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.position()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("RowSpan", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.row_span()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<(&str, dbus::Path), _>("Table", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.table()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiText {
    fn get_string_at_offset(&self, offset: i32, granularity: u32) -> Result<(String, i32, i32), tree::MethodErr>;
    fn get_text(&self, start_offset: i32, end_offset: i32) -> Result<String, tree::MethodErr>;
    fn set_caret_offset_(&self, offset: i32) -> Result<bool, tree::MethodErr>;
    fn get_text_before_offset(&self, offset: i32, type_: u32) -> Result<(String, i32, i32), tree::MethodErr>;
    fn get_text_at_offset(&self, offset: i32, type_: u32) -> Result<(String, i32, i32), tree::MethodErr>;
    fn get_text_after_offset(&self, offset: i32, type_: u32) -> Result<(String, i32, i32), tree::MethodErr>;
    fn get_character_at_offset(&self, offset: i32) -> Result<i32, tree::MethodErr>;
    fn get_attribute_value(&self, offset: i32, attribute_name: &str) -> Result<String, tree::MethodErr>;
    fn get_attributes(&self, offset: i32) -> Result<(::std::collections::HashMap<String, String>, i32, i32), tree::MethodErr>;
    fn get_default_attributes(&self) -> Result<::std::collections::HashMap<String, String>, tree::MethodErr>;
    fn get_character_extents(&self, offset: i32, coord_type: u32) -> Result<(i32, i32, i32, i32), tree::MethodErr>;
    fn get_offset_at_point(&self, x_: i32, y_: i32, coord_type: u32) -> Result<i32, tree::MethodErr>;
    fn get_nselections(&self) -> Result<i32, tree::MethodErr>;
    fn get_selection(&self, selection_num: i32) -> Result<(i32, i32), tree::MethodErr>;
    fn add_selection(&self, start_offset: i32, end_offset: i32) -> Result<bool, tree::MethodErr>;
    fn remove_selection(&self, selection_num: i32) -> Result<bool, tree::MethodErr>;
    fn set_selection(&self, selection_num: i32, start_offset: i32, end_offset: i32) -> Result<bool, tree::MethodErr>;
    fn get_range_extents(&self, start_offset: i32, end_offset: i32, coord_type: u32) -> Result<(i32, i32, i32, i32), tree::MethodErr>;
    fn get_bounded_ranges(&self, x_: i32, y_: i32, width: i32, height: i32, coord_type: u32, x_clip_type: u32, y_clip_type: u32) -> Result<Vec<(i32, i32, String, arg::Variant<Box<dyn arg::RefArg + 'static>>)>, tree::MethodErr>;
    fn get_attribute_run(&self, offset: i32, include_defaults: bool) -> Result<(::std::collections::HashMap<String, String>, i32, i32), tree::MethodErr>;
    fn get_default_attribute_set(&self) -> Result<::std::collections::HashMap<String, String>, tree::MethodErr>;
    fn scroll_substring_to(&self, start_offset: i32, end_offset: i32, type_: u32) -> Result<bool, tree::MethodErr>;
    fn scroll_substring_to_point(&self, start_offset: i32, end_offset: i32, type_: u32, x_: i32, y_: i32) -> Result<bool, tree::MethodErr>;
    fn character_count(&self) -> Result<i32, tree::MethodErr>;
    fn caret_offset(&self) -> Result<i32, tree::MethodErr>;
}

pub fn org_a11y_atspi_text_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiText,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Text", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let offset: i32 = i.read()?;
        let granularity: u32 = i.read()?;
        let d = fclone(minfo);
        let (arg0, start_offset, end_offset) = d.get_string_at_offset(offset, granularity)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(start_offset);
        let rm = rm.append1(end_offset);
        Ok(vec!(rm))
    };
    let m = factory.method("GetStringAtOffset", Default::default(), h);
    let m = m.in_arg(("offset", "i"));
    let m = m.in_arg(("granularity", "u"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("startOffset", "i"));
    let m = m.out_arg(("endOffset", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let start_offset: i32 = i.read()?;
        let end_offset: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_text(start_offset, end_offset)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetText", Default::default(), h);
    let m = m.in_arg(("startOffset", "i"));
    let m = m.in_arg(("endOffset", "i"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let offset: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.set_caret_offset_(offset)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("SetCaretOffset", Default::default(), h);
    let m = m.in_arg(("offset", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let offset: i32 = i.read()?;
        let type_: u32 = i.read()?;
        let d = fclone(minfo);
        let (arg0, start_offset, end_offset) = d.get_text_before_offset(offset, type_)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(start_offset);
        let rm = rm.append1(end_offset);
        Ok(vec!(rm))
    };
    let m = factory.method("GetTextBeforeOffset", Default::default(), h);
    let m = m.in_arg(("offset", "i"));
    let m = m.in_arg(("type", "u"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("startOffset", "i"));
    let m = m.out_arg(("endOffset", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let offset: i32 = i.read()?;
        let type_: u32 = i.read()?;
        let d = fclone(minfo);
        let (arg0, start_offset, end_offset) = d.get_text_at_offset(offset, type_)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(start_offset);
        let rm = rm.append1(end_offset);
        Ok(vec!(rm))
    };
    let m = factory.method("GetTextAtOffset", Default::default(), h);
    let m = m.in_arg(("offset", "i"));
    let m = m.in_arg(("type", "u"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("startOffset", "i"));
    let m = m.out_arg(("endOffset", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let offset: i32 = i.read()?;
        let type_: u32 = i.read()?;
        let d = fclone(minfo);
        let (arg0, start_offset, end_offset) = d.get_text_after_offset(offset, type_)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(start_offset);
        let rm = rm.append1(end_offset);
        Ok(vec!(rm))
    };
    let m = factory.method("GetTextAfterOffset", Default::default(), h);
    let m = m.in_arg(("offset", "i"));
    let m = m.in_arg(("type", "u"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("startOffset", "i"));
    let m = m.out_arg(("endOffset", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let offset: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_character_at_offset(offset)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetCharacterAtOffset", Default::default(), h);
    let m = m.in_arg(("offset", "i"));
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let offset: i32 = i.read()?;
        let attribute_name: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_attribute_value(offset, attribute_name)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAttributeValue", Default::default(), h);
    let m = m.in_arg(("offset", "i"));
    let m = m.in_arg(("attributeName", "s"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let offset: i32 = i.read()?;
        let d = fclone(minfo);
        let (arg0, start_offset, end_offset) = d.get_attributes(offset)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(start_offset);
        let rm = rm.append1(end_offset);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAttributes", Default::default(), h);
    let m = m.in_arg(("offset", "i"));
    let m = m.out_arg(("", "a{ss}"));
    let m = m.out_arg(("startOffset", "i"));
    let m = m.out_arg(("endOffset", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_default_attributes()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetDefaultAttributes", Default::default(), h);
    let m = m.out_arg(("", "a{ss}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let offset: i32 = i.read()?;
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let (x_, y_, width, height) = d.get_character_extents(offset, coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(x_);
        let rm = rm.append1(y_);
        let rm = rm.append1(width);
        let rm = rm.append1(height);
        Ok(vec!(rm))
    };
    let m = factory.method("GetCharacterExtents", Default::default(), h);
    let m = m.in_arg(("offset", "i"));
    let m = m.in_arg(("coordType", "u"));
    let m = m.out_arg(("x", "i"));
    let m = m.out_arg(("y", "i"));
    let m = m.out_arg(("width", "i"));
    let m = m.out_arg(("height", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_offset_at_point(x_, y_, coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetOffsetAtPoint", Default::default(), h);
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let m = m.in_arg(("coordType", "u"));
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_nselections()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetNSelections", Default::default(), h);
    let m = m.out_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let selection_num: i32 = i.read()?;
        let d = fclone(minfo);
        let (start_offset, end_offset) = d.get_selection(selection_num)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(start_offset);
        let rm = rm.append1(end_offset);
        Ok(vec!(rm))
    };
    let m = factory.method("GetSelection", Default::default(), h);
    let m = m.in_arg(("selectionNum", "i"));
    let m = m.out_arg(("startOffset", "i"));
    let m = m.out_arg(("endOffset", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let start_offset: i32 = i.read()?;
        let end_offset: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.add_selection(start_offset, end_offset)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("AddSelection", Default::default(), h);
    let m = m.in_arg(("startOffset", "i"));
    let m = m.in_arg(("endOffset", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let selection_num: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.remove_selection(selection_num)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("RemoveSelection", Default::default(), h);
    let m = m.in_arg(("selectionNum", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let selection_num: i32 = i.read()?;
        let start_offset: i32 = i.read()?;
        let end_offset: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.set_selection(selection_num, start_offset, end_offset)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("SetSelection", Default::default(), h);
    let m = m.in_arg(("selectionNum", "i"));
    let m = m.in_arg(("startOffset", "i"));
    let m = m.in_arg(("endOffset", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let start_offset: i32 = i.read()?;
        let end_offset: i32 = i.read()?;
        let coord_type: u32 = i.read()?;
        let d = fclone(minfo);
        let (x_, y_, width, height) = d.get_range_extents(start_offset, end_offset, coord_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(x_);
        let rm = rm.append1(y_);
        let rm = rm.append1(width);
        let rm = rm.append1(height);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRangeExtents", Default::default(), h);
    let m = m.in_arg(("startOffset", "i"));
    let m = m.in_arg(("endOffset", "i"));
    let m = m.in_arg(("coordType", "u"));
    let m = m.out_arg(("x", "i"));
    let m = m.out_arg(("y", "i"));
    let m = m.out_arg(("width", "i"));
    let m = m.out_arg(("height", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let width: i32 = i.read()?;
        let height: i32 = i.read()?;
        let coord_type: u32 = i.read()?;
        let x_clip_type: u32 = i.read()?;
        let y_clip_type: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_bounded_ranges(x_, y_, width, height, coord_type, x_clip_type, y_clip_type)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetBoundedRanges", Default::default(), h);
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let m = m.in_arg(("width", "i"));
    let m = m.in_arg(("height", "i"));
    let m = m.in_arg(("coordType", "u"));
    let m = m.in_arg(("xClipType", "u"));
    let m = m.in_arg(("yClipType", "u"));
    let m = m.out_arg(("", "a(iisv)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let offset: i32 = i.read()?;
        let include_defaults: bool = i.read()?;
        let d = fclone(minfo);
        let (arg0, start_offset, end_offset) = d.get_attribute_run(offset, include_defaults)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(start_offset);
        let rm = rm.append1(end_offset);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAttributeRun", Default::default(), h);
    let m = m.in_arg(("offset", "i"));
    let m = m.in_arg(("includeDefaults", "b"));
    let m = m.out_arg(("", "a{ss}"));
    let m = m.out_arg(("startOffset", "i"));
    let m = m.out_arg(("endOffset", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_default_attribute_set()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetDefaultAttributeSet", Default::default(), h);
    let m = m.out_arg(("", "a{ss}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let start_offset: i32 = i.read()?;
        let end_offset: i32 = i.read()?;
        let type_: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.scroll_substring_to(start_offset, end_offset, type_)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("ScrollSubstringTo", Default::default(), h);
    let m = m.in_arg(("startOffset", "i"));
    let m = m.in_arg(("endOffset", "i"));
    let m = m.in_arg(("type", "u"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let start_offset: i32 = i.read()?;
        let end_offset: i32 = i.read()?;
        let type_: u32 = i.read()?;
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.scroll_substring_to_point(start_offset, end_offset, type_, x_, y_)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("ScrollSubstringToPoint", Default::default(), h);
    let m = m.in_arg(("startOffset", "i"));
    let m = m.in_arg(("endOffset", "i"));
    let m = m.in_arg(("type", "u"));
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let p = factory.property::<i32, _>("CharacterCount", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.character_count()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i32, _>("CaretOffset", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.caret_offset()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiEditableText {
    fn set_text_contents(&self, new_contents: &str) -> Result<bool, tree::MethodErr>;
    fn insert_text(&self, position: i32, text: &str, length: i32) -> Result<bool, tree::MethodErr>;
    fn copy_text(&self, start_pos: i32, end_pos: i32) -> Result<(), tree::MethodErr>;
    fn cut_text(&self, start_pos: i32, end_pos: i32) -> Result<bool, tree::MethodErr>;
    fn delete_text(&self, start_pos: i32, end_pos: i32) -> Result<bool, tree::MethodErr>;
    fn paste_text(&self, position: i32) -> Result<bool, tree::MethodErr>;
}

pub fn org_a11y_atspi_editable_text_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgA11yAtspiEditableText,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.EditableText", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let new_contents: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.set_text_contents(new_contents)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("SetTextContents", Default::default(), h);
    let m = m.in_arg(("newContents", "s"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let position: i32 = i.read()?;
        let text: &str = i.read()?;
        let length: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.insert_text(position, text, length)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("InsertText", Default::default(), h);
    let m = m.in_arg(("position", "i"));
    let m = m.in_arg(("text", "s"));
    let m = m.in_arg(("length", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let start_pos: i32 = i.read()?;
        let end_pos: i32 = i.read()?;
        let d = fclone(minfo);
        d.copy_text(start_pos, end_pos)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("CopyText", Default::default(), h);
    let m = m.in_arg(("startPos", "i"));
    let m = m.in_arg(("endPos", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let start_pos: i32 = i.read()?;
        let end_pos: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.cut_text(start_pos, end_pos)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("CutText", Default::default(), h);
    let m = m.in_arg(("startPos", "i"));
    let m = m.in_arg(("endPos", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let start_pos: i32 = i.read()?;
        let end_pos: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.delete_text(start_pos, end_pos)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("DeleteText", Default::default(), h);
    let m = m.in_arg(("startPos", "i"));
    let m = m.in_arg(("endPos", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let position: i32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.paste_text(position)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("PasteText", Default::default(), h);
    let m = m.in_arg(("position", "i"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);
    i
}

pub trait OrgA11yAtspiCache {
    fn get_items(&self) -> Result<Vec<((String, dbus::Path<'static>), (String, dbus::Path<'static>), i32, i32, Vec<String>, String, u32, String, Vec<u32>)>, tree::MethodErr>;
}

pub fn org_a11y_atspi_cache_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Signal: Default,
    T: OrgA11yAtspiCache,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Cache", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let nodes = d.get_items()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(nodes);
        Ok(vec!(rm))
    };
    let m = factory.method("GetItems", Default::default(), h);
    let m = m.out_arg(("nodes", "a((so)(so)iiassusau)"));
    let i = i.add_m(m);
    let s = factory.signal("AddAccessible", Default::default());
    let s = s.arg(("nodeAdded", "((so)(so)iiassusau)"));
    let i = i.add_s(s);
    let s = factory.signal("RemoveAccessible", Default::default());
    let s = s.arg(("nodeRemoved", "(so)"));
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgA11yAtspiCacheAddAccessible {
    pub node_added: ((String, dbus::Path<'static>), (String, dbus::Path<'static>), i32, i32, Vec<String>, String, u32, String, Vec<u32>),
}

impl arg::AppendAll for OrgA11yAtspiCacheAddAccessible {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.node_added, i);
    }
}

impl arg::ReadAll for OrgA11yAtspiCacheAddAccessible {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgA11yAtspiCacheAddAccessible {
            node_added: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgA11yAtspiCacheAddAccessible {
    const NAME: &'static str = "AddAccessible";
    const INTERFACE: &'static str = "org.a11y.atspi.Cache";
}

#[derive(Debug)]
pub struct OrgA11yAtspiCacheRemoveAccessible {
    pub node_removed: (String, dbus::Path<'static>),
}

impl arg::AppendAll for OrgA11yAtspiCacheRemoveAccessible {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.node_removed, i);
    }
}

impl arg::ReadAll for OrgA11yAtspiCacheRemoveAccessible {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgA11yAtspiCacheRemoveAccessible {
            node_removed: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgA11yAtspiCacheRemoveAccessible {
    const NAME: &'static str = "RemoveAccessible";
    const INTERFACE: &'static str = "org.a11y.atspi.Cache";
}

pub trait OrgA11yAtspiValue {
    fn minimum_value(&self) -> Result<f64, tree::MethodErr>;
    fn maximum_value(&self) -> Result<f64, tree::MethodErr>;
    fn minimum_increment(&self) -> Result<f64, tree::MethodErr>;
    fn current_value(&self) -> Result<f64, tree::MethodErr>;
    fn set_current_value(&self, value: f64) -> Result<(), tree::MethodErr>;
}

pub fn org_a11y_atspi_value_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yAtspiValue,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Value", data);
    let f = ::std::sync::Arc::new(f);
    let p = factory.property::<f64, _>("MinimumValue", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.minimum_value()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<f64, _>("MaximumValue", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.maximum_value()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<f64, _>("MinimumIncrement", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.minimum_increment()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<f64, _>("CurrentValue", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.current_value()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_current_value(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yAtspiRegistry {
    fn register_event(&self, event: &str) -> Result<(), tree::MethodErr>;
    fn deregister_event(&self, event: &str) -> Result<(), tree::MethodErr>;
    fn get_registered_events(&self) -> Result<Vec<(String, String)>, tree::MethodErr>;
}

pub fn org_a11y_atspi_registry_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Signal: Default,
    T: OrgA11yAtspiRegistry,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.Registry", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let event: &str = i.read()?;
        let d = fclone(minfo);
        d.register_event(event)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterEvent", Default::default(), h);
    let m = m.in_arg(("event", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let event: &str = i.read()?;
        let d = fclone(minfo);
        d.deregister_event(event)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("DeregisterEvent", Default::default(), h);
    let m = m.in_arg(("event", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let events = d.get_registered_events()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(events);
        Ok(vec!(rm))
    };
    let m = factory.method("GetRegisteredEvents", Default::default(), h);
    let m = m.out_arg(("events", "a(ss)"));
    let i = i.add_m(m);
    let s = factory.signal("EventListenerRegistered", Default::default());
    let s = s.arg(("bus", "s"));
    let s = s.arg(("path", "s"));
    let i = i.add_s(s);
    let s = factory.signal("EventListenerDeregistered", Default::default());
    let s = s.arg(("bus", "s"));
    let s = s.arg(("path", "s"));
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgA11yAtspiRegistryEventListenerRegistered {
    pub bus: String,
    pub path: String,
}

impl arg::AppendAll for OrgA11yAtspiRegistryEventListenerRegistered {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.bus, i);
        arg::RefArg::append(&self.path, i);
    }
}

impl arg::ReadAll for OrgA11yAtspiRegistryEventListenerRegistered {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgA11yAtspiRegistryEventListenerRegistered {
            bus: i.read()?,
            path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgA11yAtspiRegistryEventListenerRegistered {
    const NAME: &'static str = "EventListenerRegistered";
    const INTERFACE: &'static str = "org.a11y.atspi.Registry";
}

#[derive(Debug)]
pub struct OrgA11yAtspiRegistryEventListenerDeregistered {
    pub bus: String,
    pub path: String,
}

impl arg::AppendAll for OrgA11yAtspiRegistryEventListenerDeregistered {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.bus, i);
        arg::RefArg::append(&self.path, i);
    }
}

impl arg::ReadAll for OrgA11yAtspiRegistryEventListenerDeregistered {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgA11yAtspiRegistryEventListenerDeregistered {
            bus: i.read()?,
            path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgA11yAtspiRegistryEventListenerDeregistered {
    const NAME: &'static str = "EventListenerDeregistered";
    const INTERFACE: &'static str = "org.a11y.atspi.Registry";
}

pub trait OrgA11yAtspiDeviceEventController {
    fn register_keystroke_listener(&self, listener: dbus::Path, keys: Vec<(i32, i32, &str, i32)>, mask: u32, type_: Vec<u32>, mode: (bool, bool, bool)) -> Result<bool, tree::MethodErr>;
    fn deregister_keystroke_listener(&self, listener: dbus::Path, keys: Vec<(i32, i32, &str, i32)>, mask: u32, type_: u32) -> Result<(), tree::MethodErr>;
    fn register_device_event_listener(&self, listener: dbus::Path, types: u32) -> Result<bool, tree::MethodErr>;
    fn deregister_device_event_listener(&self, listener: dbus::Path, types: u32) -> Result<(), tree::MethodErr>;
    fn generate_keyboard_event(&self, keycode: i32, keystring: &str, type_: u32) -> Result<(), tree::MethodErr>;
    fn generate_mouse_event(&self, x_: i32, y_: i32, event_name: &str) -> Result<(), tree::MethodErr>;
    fn notify_listeners_sync(&self, event: (u32, i32, u32, u32, i32, &str, bool)) -> Result<bool, tree::MethodErr>;
    fn notify_listeners_async(&self, event: (u32, i32, u32, u32, i32, &str, bool)) -> Result<(), tree::MethodErr>;
}

pub fn org_a11y_atspi_device_event_controller_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgA11yAtspiDeviceEventController,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.DeviceEventController", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let listener: dbus::Path = i.read()?;
        let keys: Vec<(i32, i32, &str, i32)> = i.read()?;
        let mask: u32 = i.read()?;
        let type_: Vec<u32> = i.read()?;
        let mode: (bool, bool, bool) = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.register_keystroke_listener(listener, keys, mask, type_, mode)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterKeystrokeListener", Default::default(), h);
    let m = m.in_arg(("listener", "o"));
    let m = m.in_arg(("keys", "a(iisi)"));
    let m = m.in_arg(("mask", "u"));
    let m = m.in_arg(("type", "au"));
    let m = m.in_arg(("mode", "(bbb)"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let listener: dbus::Path = i.read()?;
        let keys: Vec<(i32, i32, &str, i32)> = i.read()?;
        let mask: u32 = i.read()?;
        let type_: u32 = i.read()?;
        let d = fclone(minfo);
        d.deregister_keystroke_listener(listener, keys, mask, type_)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("DeregisterKeystrokeListener", Default::default(), h);
    let m = m.in_arg(("listener", "o"));
    let m = m.in_arg(("keys", "a(iisi)"));
    let m = m.in_arg(("mask", "u"));
    let m = m.in_arg(("type", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let listener: dbus::Path = i.read()?;
        let types: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.register_device_event_listener(listener, types)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterDeviceEventListener", Default::default(), h);
    let m = m.in_arg(("listener", "o"));
    let m = m.in_arg(("types", "u"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let listener: dbus::Path = i.read()?;
        let types: u32 = i.read()?;
        let d = fclone(minfo);
        d.deregister_device_event_listener(listener, types)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("DeregisterDeviceEventListener", Default::default(), h);
    let m = m.in_arg(("listener", "o"));
    let m = m.in_arg(("types", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let keycode: i32 = i.read()?;
        let keystring: &str = i.read()?;
        let type_: u32 = i.read()?;
        let d = fclone(minfo);
        d.generate_keyboard_event(keycode, keystring, type_)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("GenerateKeyboardEvent", Default::default(), h);
    let m = m.in_arg(("keycode", "i"));
    let m = m.in_arg(("keystring", "s"));
    let m = m.in_arg(("type", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let x_: i32 = i.read()?;
        let y_: i32 = i.read()?;
        let event_name: &str = i.read()?;
        let d = fclone(minfo);
        d.generate_mouse_event(x_, y_, event_name)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("GenerateMouseEvent", Default::default(), h);
    let m = m.in_arg(("x", "i"));
    let m = m.in_arg(("y", "i"));
    let m = m.in_arg(("eventName", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let event: (u32, i32, u32, u32, i32, &str, bool) = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.notify_listeners_sync(event)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("NotifyListenersSync", Default::default(), h);
    let m = m.in_arg(("event", "(uiuuisb)"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let event: (u32, i32, u32, u32, i32, &str, bool) = i.read()?;
        let d = fclone(minfo);
        d.notify_listeners_async(event)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("NotifyListenersAsync", Default::default(), h);
    let m = m.in_arg(("event", "(uiuuisb)"));
    let i = i.add_m(m);
    i
}

pub trait OrgA11yAtspiDeviceEventListener {
    fn notify_event(&self, event: (u32, i32, u32, u32, i32, &str, bool)) -> Result<bool, tree::MethodErr>;
}

pub fn org_a11y_atspi_device_event_listener_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgA11yAtspiDeviceEventListener,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.atspi.DeviceEventListener", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let event: (u32, i32, u32, u32, i32, &str, bool) = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.notify_event(event)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("NotifyEvent", Default::default(), h);
    let m = m.in_arg(("event", "(uiuuisb)"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);
    i
}
// This code was autogenerated with `dbus-codegen-rust `, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_tree as tree;

pub trait OrgFreedesktopDBusProperties {
    fn get(&self, interface_name: &str, property_name: &str) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, tree::MethodErr>;
    fn get_all(&self, interface_name: &str) -> Result<arg::PropMap, tree::MethodErr>;
    fn set(&self, interface_name: &str, property_name: &str, value: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), tree::MethodErr>;
}

pub fn org_freedesktop_dbus_properties_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Signal: Default,
    T: OrgFreedesktopDBusProperties,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Properties", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface_name: &str = i.read()?;
        let property_name: &str = i.read()?;
        let d = fclone(minfo);
        let value = d.get(interface_name, property_name)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(value);
        Ok(vec!(rm))
    };
    let m = factory.method("Get", Default::default(), h);
    let m = m.in_arg(("interface_name", "s"));
    let m = m.in_arg(("property_name", "s"));
    let m = m.out_arg(("value", "v"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface_name: &str = i.read()?;
        let d = fclone(minfo);
        let properties = d.get_all(interface_name)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(properties);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAll", Default::default(), h);
    let m = m.in_arg(("interface_name", "s"));
    let m = m.out_arg(("properties", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface_name: &str = i.read()?;
        let property_name: &str = i.read()?;
        let value: arg::Variant<Box<dyn arg::RefArg>> = i.read()?;
        let d = fclone(minfo);
        d.set(interface_name, property_name, value)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Set", Default::default(), h);
    let m = m.in_arg(("interface_name", "s"));
    let m = m.in_arg(("property_name", "s"));
    let m = m.in_arg(("value", "v"));
    let i = i.add_m(m);
    let s = factory.signal("PropertiesChanged", Default::default());
    let s = s.arg(("interface_name", "s"));
    let s = s.arg(("changed_properties", "a{sv}"));
    let s = s.arg(("invalidated_properties", "as"));
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface_name: String,
    pub changed_properties: arg::PropMap,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface_name, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface_name: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_freedesktop_dbus_introspectable_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusIntrospectable,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Introspectable", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let xml_data = d.introspect()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(xml_data);
        Ok(vec!(rm))
    };
    let m = factory.method("Introspect", Default::default(), h);
    let m = m.out_arg(("xml_data", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopDBusPeer {
    fn ping(&self) -> Result<(), tree::MethodErr>;
    fn get_machine_id(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_freedesktop_dbus_peer_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusPeer,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Peer", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.ping()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Ping", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let machine_uuid = d.get_machine_id()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(machine_uuid);
        Ok(vec!(rm))
    };
    let m = factory.method("GetMachineId", Default::default(), h);
    let m = m.out_arg(("machine_uuid", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgA11yStatus {
    fn is_enabled(&self) -> Result<bool, tree::MethodErr>;
    fn set_is_enabled(&self, value: bool) -> Result<(), tree::MethodErr>;
    fn screen_reader_enabled(&self) -> Result<bool, tree::MethodErr>;
    fn set_screen_reader_enabled(&self, value: bool) -> Result<(), tree::MethodErr>;
}

pub fn org_a11y_status_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgA11yStatus,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.Status", data);
    let f = ::std::sync::Arc::new(f);
    let p = factory.property::<bool, _>("IsEnabled", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.is_enabled()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_is_enabled(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ScreenReaderEnabled", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.screen_reader_enabled()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_screen_reader_enabled(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgA11yBus {
    fn get_address(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_a11y_bus_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgA11yBus,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.a11y.Bus", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let address = d.get_address()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(address);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAddress", Default::default(), h);
    let m = m.out_arg(("address", "s"));
    let i = i.add_m(m);
    i
}
