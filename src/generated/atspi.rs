use crossroads::IfaceBuilder;
// This code was autogenerated with `dbus-codegen-rust -rn`, see https://github.com/diwic/dbus-rs
use dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_crossroads as crossroads;

pub trait OrgA11yAtspiAccessible {
    fn get_child_at_index(
        &mut self,
        index: i32,
    ) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn get_children(&mut self) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::MethodErr>;
    fn get_index_in_parent(&mut self) -> Result<i32, dbus::MethodErr>;
    fn get_relation_set(
        &mut self,
    ) -> Result<Vec<(u32, Vec<(String, dbus::Path<'static>)>)>, dbus::MethodErr>;
    fn get_role(&mut self) -> Result<u32, dbus::MethodErr>;
    fn get_role_name(&mut self) -> Result<String, dbus::MethodErr>;
    fn get_localized_role_name(&mut self) -> Result<String, dbus::MethodErr>;
    fn get_state(&mut self) -> Result<Vec<u32>, dbus::MethodErr>;
    fn get_attributes(
        &mut self,
    ) -> Result<::std::collections::HashMap<String, String>, dbus::MethodErr>;
    fn get_application(&mut self) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn get_interfaces(&mut self) -> Result<Vec<String>, dbus::MethodErr>;
    fn name(&self) -> Result<String, dbus::MethodErr>;
    fn description(&self) -> Result<String, dbus::MethodErr>;
    fn parent(&self) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn child_count(&self) -> Result<i32, dbus::MethodErr>;
    fn locale(&self) -> Result<String, dbus::MethodErr>;
    fn accessible_id(&self) -> Result<String, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_ACCESSIBLE_NAME: &str = "org.a11y.atspi.Accessible";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiAccessibleProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiAccessibleProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.Accessible").map(Self)
    }

    pub fn name(&self) -> Option<&String> {
        arg::prop_cast(self.0, "Name")
    }

    pub fn description(&self) -> Option<&String> {
        arg::prop_cast(self.0, "Description")
    }

    pub fn parent(&self) -> Option<&(String, dbus::Path<'static>)> {
        arg::prop_cast(self.0, "Parent")
    }

    pub fn child_count(&self) -> Option<i32> {
        arg::prop_cast(self.0, "ChildCount").copied()
    }

    pub fn locale(&self) -> Option<&String> {
        arg::prop_cast(self.0, "Locale")
    }

    pub fn accessible_id(&self) -> Option<&String> {
        arg::prop_cast(self.0, "AccessibleId")
    }
}

pub fn register_org_a11y_atspi_accessible<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiAccessible + Send + 'static,
{
    cr.register("org.a11y.atspi.Accessible", |b| {
        b.method(
            "GetChildAtIndex",
            ("index",),
            ("",),
            |_, t: &mut T, (index,)| t.get_child_at_index(index).map(|x| (x,)),
        );
        b.method("GetChildren", (), ("",), |_, t: &mut T, ()| {
            t.get_children().map(|x| (x,))
        });
        b.method("GetIndexInParent", (), ("",), |_, t: &mut T, ()| {
            t.get_index_in_parent().map(|x| (x,))
        });
        b.method("GetRelationSet", (), ("",), |_, t: &mut T, ()| {
            t.get_relation_set().map(|x| (x,))
        });
        b.method("GetRole", (), ("",), |_, t: &mut T, ()| {
            t.get_role().map(|x| (x,))
        });
        b.method("GetRoleName", (), ("",), |_, t: &mut T, ()| {
            t.get_role_name().map(|x| (x,))
        });
        b.method("GetLocalizedRoleName", (), ("",), |_, t: &mut T, ()| {
            t.get_localized_role_name().map(|x| (x,))
        });
        b.method("GetState", (), ("",), |_, t: &mut T, ()| {
            t.get_state().map(|x| (x,))
        });
        b.method("GetAttributes", (), ("",), |_, t: &mut T, ()| {
            t.get_attributes().map(|x| (x,))
        });
        b.method("GetApplication", (), ("",), |_, t: &mut T, ()| {
            t.get_application().map(|x| (x,))
        });
        b.method("GetInterfaces", (), ("",), |_, t: &mut T, ()| {
            t.get_interfaces().map(|x| (x,))
        });
        b.property::<String, _>("Name").get(|_, t| t.name());
        b.property::<String, _>("Description")
            .get(|_, t| t.description());
        b.property::<(String, dbus::Path<'static>), _>("Parent")
            .get(|_, t| t.parent());
        b.property::<i32, _>("ChildCount")
            .get(|_, t| t.child_count());
        b.property::<String, _>("Locale").get(|_, t| t.locale());
        b.property::<String, _>("AccessibleId")
            .get(|_, t| t.accessible_id());
    })
}

pub trait OrgA11yAtspiAction {
    fn get_description(&mut self, index: i32) -> Result<String, dbus::MethodErr>;
    fn get_name(&mut self, index: i32) -> Result<String, dbus::MethodErr>;
    fn get_localized_name(&mut self, index: i32) -> Result<String, dbus::MethodErr>;
    fn get_key_binding(&mut self, index: i32) -> Result<String, dbus::MethodErr>;
    fn get_actions(&mut self) -> Result<Vec<(String, String, String)>, dbus::MethodErr>;
    fn do_action(&mut self, index: i32) -> Result<bool, dbus::MethodErr>;
    fn nactions(&self) -> Result<i32, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_ACTION_NAME: &str = "org.a11y.atspi.Action";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiActionProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiActionProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.Action").map(Self)
    }

    pub fn nactions(&self) -> Option<i32> {
        arg::prop_cast(self.0, "NActions").copied()
    }
}

pub fn register_org_a11y_atspi_action<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiAction + Send + 'static,
{
    cr.register("org.a11y.atspi.Action", |b| {
        b.method(
            "GetDescription",
            ("index",),
            ("",),
            |_, t: &mut T, (index,)| t.get_description(index).map(|x| (x,)),
        );
        b.method("GetName", ("index",), ("",), |_, t: &mut T, (index,)| {
            t.get_name(index).map(|x| (x,))
        });
        b.method(
            "GetLocalizedName",
            ("index",),
            ("",),
            |_, t: &mut T, (index,)| t.get_localized_name(index).map(|x| (x,)),
        );
        b.method(
            "GetKeyBinding",
            ("index",),
            ("",),
            |_, t: &mut T, (index,)| t.get_key_binding(index).map(|x| (x,)),
        );
        b.method("GetActions", (), ("",), |_, t: &mut T, ()| {
            t.get_actions().map(|x| (x,))
        });
        b.method("DoAction", ("index",), ("",), |_, t: &mut T, (index,)| {
            t.do_action(index).map(|x| (x,))
        });
        b.property::<i32, _>("NActions").get(|_, t| t.nactions());
    })
}

pub trait OrgA11yAtspiApplication {
    fn get_locale(&mut self, lctype: u32) -> Result<String, dbus::MethodErr>;
    fn register_event_listener(&mut self, event: String) -> Result<(), dbus::MethodErr>;
    fn deregister_event_listener(&mut self, event: String) -> Result<(), dbus::MethodErr>;
    fn toolkit_name(&self) -> Result<String, dbus::MethodErr>;
    fn version(&self) -> Result<String, dbus::MethodErr>;
    fn atspi_version(&self) -> Result<String, dbus::MethodErr>;
    fn id(&self) -> Result<i32, dbus::MethodErr>;
    fn set_id(&self, value: i32) -> Result<(), dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_APPLICATION_NAME: &str = "org.a11y.atspi.Application";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiApplicationProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiApplicationProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.Application").map(Self)
    }

    pub fn toolkit_name(&self) -> Option<&String> {
        arg::prop_cast(self.0, "ToolkitName")
    }

    pub fn version(&self) -> Option<&String> {
        arg::prop_cast(self.0, "Version")
    }

    pub fn atspi_version(&self) -> Option<&String> {
        arg::prop_cast(self.0, "AtspiVersion")
    }

    pub fn id(&self) -> Option<i32> {
        arg::prop_cast(self.0, "Id").copied()
    }
}

pub fn register_org_a11y_atspi_application<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiApplication + Send + 'static,
{
    cr.register("org.a11y.atspi.Application", |b| {
        b.method(
            "GetLocale",
            ("lctype",),
            ("",),
            |_, t: &mut T, (lctype,)| t.get_locale(lctype).map(|x| (x,)),
        );
        b.method(
            "RegisterEventListener",
            ("event",),
            (),
            |_, t: &mut T, (event,)| t.register_event_listener(event),
        );
        b.method(
            "DeregisterEventListener",
            ("event",),
            (),
            |_, t: &mut T, (event,)| t.deregister_event_listener(event),
        );
        b.property::<String, _>("ToolkitName")
            .get(|_, t| t.toolkit_name());
        b.property::<String, _>("Version").get(|_, t| t.version());
        b.property::<String, _>("AtspiVersion")
            .get(|_, t| t.atspi_version());
        b.property::<i32, _>("Id")
            .get(|_, t| t.id())
            .set(|_, t, value| t.set_id(value).map(|_| None));
    })
}

pub trait OrgA11yAtspiCollection {
    fn get_matches(
        &mut self,
        rule: (
            Vec<i32>,
            i32,
            ::std::collections::HashMap<String, String>,
            i32,
            Vec<i32>,
            i32,
            Vec<String>,
            i32,
            bool,
        ),
        sortby: u32,
        count: i32,
        traverse: bool,
    ) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::MethodErr>;
    fn get_matches_to(
        &mut self,
        current_object: dbus::Path<'static>,
        rule: (
            Vec<i32>,
            i32,
            ::std::collections::HashMap<String, String>,
            i32,
            Vec<i32>,
            i32,
            Vec<String>,
            i32,
            bool,
        ),
        sortby: u32,
        tree: u32,
        limit_scope: bool,
        count: i32,
        traverse: bool,
    ) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::MethodErr>;
    fn get_matches_from(
        &mut self,
        current_object: dbus::Path<'static>,
        rule: (
            Vec<i32>,
            i32,
            ::std::collections::HashMap<String, String>,
            i32,
            Vec<i32>,
            i32,
            Vec<String>,
            i32,
            bool,
        ),
        sortby: u32,
        tree: u32,
        count: i32,
        traverse: bool,
    ) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::MethodErr>;
    fn get_active_descendant(&mut self) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_COLLECTION_NAME: &str = "org.a11y.atspi.Collection";

pub fn register_org_a11y_atspi_collection<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiCollection + Send + 'static,
{
    cr.register("org.a11y.atspi.Collection", |b| {
        b.method(
            "GetMatches",
            ("rule", "sortby", "count", "traverse"),
            ("",),
            |_, t: &mut T, (rule, sortby, count, traverse)| {
                t.get_matches(rule, sortby, count, traverse).map(|x| (x,))
            },
        );
        b.method(
            "GetMatchesTo",
            (
                "current_object",
                "rule",
                "sortby",
                "tree",
                "limit_scope",
                "count",
                "traverse",
            ),
            ("",),
            |_, t: &mut T, (current_object, rule, sortby, tree, limit_scope, count, traverse)| {
                t.get_matches_to(
                    current_object,
                    rule,
                    sortby,
                    tree,
                    limit_scope,
                    count,
                    traverse,
                )
                .map(|x| (x,))
            },
        );
        b.method(
            "GetMatchesFrom",
            (
                "current_object",
                "rule",
                "sortby",
                "tree",
                "count",
                "traverse",
            ),
            ("",),
            |_, t: &mut T, (current_object, rule, sortby, tree, count, traverse)| {
                t.get_matches_from(current_object, rule, sortby, tree, count, traverse)
                    .map(|x| (x,))
            },
        );
        b.method("GetActiveDescendant", (), ("",), |_, t: &mut T, ()| {
            t.get_active_descendant().map(|x| (x,))
        });
    })
}

pub trait OrgA11yAtspiComponent {
    fn contains(&mut self, x_: i32, y_: i32, coord_type: u32) -> Result<bool, dbus::MethodErr>;
    fn get_accessible_at_point(
        &mut self,
        x_: i32,
        y_: i32,
        coord_type: u32,
    ) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn get_extents(&mut self, coord_type: u32) -> Result<(i32, i32, i32, i32), dbus::MethodErr>;
    fn get_position(&mut self, coord_type: u32) -> Result<(i32, i32), dbus::MethodErr>;
    fn get_size(&mut self) -> Result<(i32, i32), dbus::MethodErr>;
    fn get_layer(&mut self) -> Result<u32, dbus::MethodErr>;
    fn get_mdizorder(&mut self) -> Result<i16, dbus::MethodErr>;
    fn grab_focus(&mut self) -> Result<bool, dbus::MethodErr>;
    fn get_alpha(&mut self) -> Result<f64, dbus::MethodErr>;
    fn set_extents(
        &mut self,
        x_: i32,
        y_: i32,
        width: i32,
        height: i32,
        coord_type: u32,
    ) -> Result<bool, dbus::MethodErr>;
    fn set_position(&mut self, x_: i32, y_: i32, coord_type: u32) -> Result<bool, dbus::MethodErr>;
    fn set_size(&mut self, width: i32, height: i32) -> Result<bool, dbus::MethodErr>;
    fn scroll_to(&mut self, type_: u32) -> Result<bool, dbus::MethodErr>;
    fn scroll_to_point(&mut self, type_: u32, x_: i32, y_: i32) -> Result<bool, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_COMPONENT_NAME: &str = "org.a11y.atspi.Component";

pub fn register_org_a11y_atspi_component<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiComponent + Send + 'static,
{
    cr.register("org.a11y.atspi.Component", |b| {
        b.method(
            "Contains",
            ("x", "y", "coord_type"),
            ("",),
            |_, t: &mut T, (x, y, coord_type)| t.contains(x, y, coord_type).map(|x| (x,)),
        );
        b.method(
            "GetAccessibleAtPoint",
            ("x", "y", "coord_type"),
            ("",),
            |_, t: &mut T, (x, y, coord_type)| {
                t.get_accessible_at_point(x, y, coord_type).map(|x| (x,))
            },
        );
        b.method(
            "GetExtents",
            ("coord_type",),
            ("",),
            |_, t: &mut T, (coord_type,)| t.get_extents(coord_type).map(|x| (x,)),
        );
        b.method(
            "GetPosition",
            ("coord_type",),
            ("x", "y"),
            |_, t: &mut T, (coord_type,)| t.get_position(coord_type),
        );
        b.method("GetSize", (), ("width", "height"), |_, t: &mut T, ()| {
            t.get_size()
        });
        b.method("GetLayer", (), ("",), |_, t: &mut T, ()| {
            t.get_layer().map(|x| (x,))
        });
        b.method("GetMDIZOrder", (), ("",), |_, t: &mut T, ()| {
            t.get_mdizorder().map(|x| (x,))
        });
        b.method("GrabFocus", (), ("",), |_, t: &mut T, ()| {
            t.grab_focus().map(|x| (x,))
        });
        b.method("GetAlpha", (), ("",), |_, t: &mut T, ()| {
            t.get_alpha().map(|x| (x,))
        });
        b.method(
            "SetExtents",
            ("x", "y", "width", "height", "coord_type"),
            ("",),
            |_, t: &mut T, (x, y, width, height, coord_type)| {
                t.set_extents(x, y, width, height, coord_type).map(|x| (x,))
            },
        );
        b.method(
            "SetPosition",
            ("x", "y", "coord_type"),
            ("",),
            |_, t: &mut T, (x, y, coord_type)| t.set_position(x, y, coord_type).map(|x| (x,)),
        );
        b.method(
            "SetSize",
            ("width", "height"),
            ("",),
            |_, t: &mut T, (width, height)| t.set_size(width, height).map(|x| (x,)),
        );
        b.method("ScrollTo", ("type",), ("",), |_, t: &mut T, (r#type,)| {
            t.scroll_to(r#type).map(|x| (x,))
        });
        b.method(
            "ScrollToPoint",
            ("type", "x", "y"),
            ("",),
            |_, t: &mut T, (r#type, x, y)| t.scroll_to_point(r#type, x, y).map(|x| (x,)),
        );
    })
}

pub trait OrgA11yAtspiDocument {
    fn get_locale(&mut self) -> Result<String, dbus::MethodErr>;
    fn get_attribute_value(&mut self, attributename: String) -> Result<String, dbus::MethodErr>;
    fn get_attributes(
        &mut self,
    ) -> Result<::std::collections::HashMap<String, String>, dbus::MethodErr>;
    fn current_page_number(&self) -> Result<i32, dbus::MethodErr>;
    fn page_count(&self) -> Result<i32, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_DOCUMENT_NAME: &str = "org.a11y.atspi.Document";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiDocumentProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiDocumentProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.Document").map(Self)
    }

    pub fn current_page_number(&self) -> Option<i32> {
        arg::prop_cast(self.0, "CurrentPageNumber").copied()
    }

    pub fn page_count(&self) -> Option<i32> {
        arg::prop_cast(self.0, "PageCount").copied()
    }
}

pub fn register_org_a11y_atspi_document<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiDocument + Send + 'static,
{
    cr.register("org.a11y.atspi.Document", |b| {
        b.method("GetLocale", (), ("",), |_, t: &mut T, ()| {
            t.get_locale().map(|x| (x,))
        });
        b.method(
            "GetAttributeValue",
            ("attributename",),
            ("",),
            |_, t: &mut T, (attributename,)| t.get_attribute_value(attributename).map(|x| (x,)),
        );
        b.method("GetAttributes", (), ("",), |_, t: &mut T, ()| {
            t.get_attributes().map(|x| (x,))
        });
        b.property::<i32, _>("CurrentPageNumber")
            .get(|_, t| t.current_page_number());
        b.property::<i32, _>("PageCount").get(|_, t| t.page_count());
    })
}

pub trait OrgA11yAtspiHypertext {
    fn get_nlinks(&mut self) -> Result<i32, dbus::MethodErr>;
    fn get_link(
        &mut self,
        link_index: i32,
    ) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn get_link_index(&mut self, character_index: i32) -> Result<i32, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_HYPERTEXT_NAME: &str = "org.a11y.atspi.Hypertext";

pub fn register_org_a11y_atspi_hypertext<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiHypertext + Send + 'static,
{
    cr.register("org.a11y.atspi.Hypertext", |b| {
        b.method("GetNLinks", (), ("",), |_, t: &mut T, ()| {
            t.get_nlinks().map(|x| (x,))
        });
        b.method(
            "GetLink",
            ("linkIndex",),
            ("",),
            |_, t: &mut T, (linkIndex,)| t.get_link(linkIndex).map(|x| (x,)),
        );
        b.method(
            "GetLinkIndex",
            ("characterIndex",),
            ("",),
            |_, t: &mut T, (characterIndex,)| t.get_link_index(characterIndex).map(|x| (x,)),
        );
    })
}

pub trait OrgA11yAtspiHyperlink {
    fn get_object(&mut self, i_: i32) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn get_uri(&mut self, i_: i32) -> Result<String, dbus::MethodErr>;
    fn is_valid(&mut self) -> Result<bool, dbus::MethodErr>;
    fn nanchors(&self) -> Result<i16, dbus::MethodErr>;
    fn start_index(&self) -> Result<i32, dbus::MethodErr>;
    fn end_index(&self) -> Result<i32, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_HYPERLINK_NAME: &str = "org.a11y.atspi.Hyperlink";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiHyperlinkProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiHyperlinkProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.Hyperlink").map(Self)
    }

    pub fn nanchors(&self) -> Option<i16> {
        arg::prop_cast(self.0, "NAnchors").copied()
    }

    pub fn start_index(&self) -> Option<i32> {
        arg::prop_cast(self.0, "StartIndex").copied()
    }

    pub fn end_index(&self) -> Option<i32> {
        arg::prop_cast(self.0, "EndIndex").copied()
    }
}

pub fn register_org_a11y_atspi_hyperlink<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiHyperlink + Send + 'static,
{
    cr.register("org.a11y.atspi.Hyperlink", |b| {
        b.method("GetObject", ("i",), ("",), |_, t: &mut T, (i,)| {
            t.get_object(i).map(|x| (x,))
        });
        b.method("GetURI", ("i",), ("",), |_, t: &mut T, (i,)| {
            t.get_uri(i).map(|x| (x,))
        });
        b.method("IsValid", (), ("",), |_, t: &mut T, ()| {
            t.is_valid().map(|x| (x,))
        });
        b.property::<i16, _>("NAnchors").get(|_, t| t.nanchors());
        b.property::<i32, _>("StartIndex")
            .get(|_, t| t.start_index());
        b.property::<i32, _>("EndIndex").get(|_, t| t.end_index());
    })
}

pub trait OrgA11yAtspiImage {
    fn get_image_extents(
        &mut self,
        coord_type: u32,
    ) -> Result<(i32, i32, i32, i32), dbus::MethodErr>;
    fn get_image_position(&mut self, coord_type: u32) -> Result<(i32, i32), dbus::MethodErr>;
    fn get_image_size(&mut self) -> Result<(i32, i32), dbus::MethodErr>;
    fn image_description(&self) -> Result<String, dbus::MethodErr>;
    fn image_locale(&self) -> Result<String, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_IMAGE_NAME: &str = "org.a11y.atspi.Image";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiImageProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiImageProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.Image").map(Self)
    }

    pub fn image_description(&self) -> Option<&String> {
        arg::prop_cast(self.0, "ImageDescription")
    }

    pub fn image_locale(&self) -> Option<&String> {
        arg::prop_cast(self.0, "ImageLocale")
    }
}

pub fn register_org_a11y_atspi_image<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiImage + Send + 'static,
{
    cr.register("org.a11y.atspi.Image", |b| {
        b.method(
            "GetImageExtents",
            ("coordType",),
            ("",),
            |_, t: &mut T, (coordType,)| t.get_image_extents(coordType).map(|x| (x,)),
        );
        b.method(
            "GetImagePosition",
            ("coordType",),
            ("x", "y"),
            |_, t: &mut T, (coordType,)| t.get_image_position(coordType),
        );
        b.method(
            "GetImageSize",
            (),
            ("width", "height"),
            |_, t: &mut T, ()| t.get_image_size(),
        );
        b.property::<String, _>("ImageDescription")
            .get(|_, t| t.image_description());
        b.property::<String, _>("ImageLocale")
            .get(|_, t| t.image_locale());
    })
}

pub trait OrgA11yAtspiSelection {
    fn get_selected_child(
        &mut self,
        selected_child_index: i32,
    ) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn select_child(&mut self, child_index: i32) -> Result<bool, dbus::MethodErr>;
    fn deselect_selected_child(
        &mut self,
        selected_child_index: i32,
    ) -> Result<bool, dbus::MethodErr>;
    fn is_child_selected(&mut self, child_index: i32) -> Result<bool, dbus::MethodErr>;
    fn select_all(&mut self) -> Result<bool, dbus::MethodErr>;
    fn clear_selection(&mut self) -> Result<bool, dbus::MethodErr>;
    fn deselect_child(&mut self, child_index: i32) -> Result<bool, dbus::MethodErr>;
    fn nselected_children(&self) -> Result<i32, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_SELECTION_NAME: &str = "org.a11y.atspi.Selection";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiSelectionProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiSelectionProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.Selection").map(Self)
    }

    pub fn nselected_children(&self) -> Option<i32> {
        arg::prop_cast(self.0, "NSelectedChildren").copied()
    }
}

pub fn register_org_a11y_atspi_selection<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiSelection + Send + 'static,
{
    cr.register("org.a11y.atspi.Selection", |b| {
        b.method(
            "GetSelectedChild",
            ("selectedChildIndex",),
            ("",),
            |_, t: &mut T, (selectedChildIndex,)| {
                t.get_selected_child(selectedChildIndex).map(|x| (x,))
            },
        );
        b.method(
            "SelectChild",
            ("childIndex",),
            ("",),
            |_, t: &mut T, (childIndex,)| t.select_child(childIndex).map(|x| (x,)),
        );
        b.method(
            "DeselectSelectedChild",
            ("selectedChildIndex",),
            ("",),
            |_, t: &mut T, (selectedChildIndex,)| {
                t.deselect_selected_child(selectedChildIndex).map(|x| (x,))
            },
        );
        b.method(
            "IsChildSelected",
            ("childIndex",),
            ("",),
            |_, t: &mut T, (childIndex,)| t.is_child_selected(childIndex).map(|x| (x,)),
        );
        b.method("SelectAll", (), ("",), |_, t: &mut T, ()| {
            t.select_all().map(|x| (x,))
        });
        b.method("ClearSelection", (), ("",), |_, t: &mut T, ()| {
            t.clear_selection().map(|x| (x,))
        });
        b.method(
            "DeselectChild",
            ("childIndex",),
            ("",),
            |_, t: &mut T, (childIndex,)| t.deselect_child(childIndex).map(|x| (x,)),
        );
        b.property::<i32, _>("NSelectedChildren")
            .get(|_, t| t.nselected_children());
    })
}

pub trait OrgA11yAtspiTable {
    fn get_accessible_at(
        &mut self,
        row: i32,
        column: i32,
    ) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn get_index_at(&mut self, row: i32, column: i32) -> Result<i32, dbus::MethodErr>;
    fn get_row_at_index(&mut self, index: i32) -> Result<i32, dbus::MethodErr>;
    fn get_column_at_index(&mut self, index: i32) -> Result<i32, dbus::MethodErr>;
    fn get_row_description(&mut self, row: i32) -> Result<String, dbus::MethodErr>;
    fn get_column_description(&mut self, column: i32) -> Result<String, dbus::MethodErr>;
    fn get_row_extent_at(&mut self, row: i32, column: i32) -> Result<i32, dbus::MethodErr>;
    fn get_column_extent_at(&mut self, row: i32, column: i32) -> Result<i32, dbus::MethodErr>;
    fn get_row_header(
        &mut self,
        row: i32,
    ) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn get_column_header(
        &mut self,
        column: i32,
    ) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn get_selected_rows(&mut self) -> Result<Vec<i32>, dbus::MethodErr>;
    fn get_selected_columns(&mut self) -> Result<Vec<i32>, dbus::MethodErr>;
    fn is_row_selected(&mut self, row: i32) -> Result<bool, dbus::MethodErr>;
    fn is_column_selected(&mut self, column: i32) -> Result<bool, dbus::MethodErr>;
    fn is_selected(&mut self, row: i32, column: i32) -> Result<bool, dbus::MethodErr>;
    fn add_row_selection(&mut self, row: i32) -> Result<bool, dbus::MethodErr>;
    fn add_column_selection(&mut self, column: i32) -> Result<bool, dbus::MethodErr>;
    fn remove_row_selection(&mut self, row: i32) -> Result<bool, dbus::MethodErr>;
    fn remove_column_selection(&mut self, column: i32) -> Result<bool, dbus::MethodErr>;
    fn get_row_column_extents_at_index(
        &mut self,
        index: i32,
    ) -> Result<(bool, i32, i32, i32, i32, bool), dbus::MethodErr>;
    fn nrows(&self) -> Result<i32, dbus::MethodErr>;
    fn ncolumns(&self) -> Result<i32, dbus::MethodErr>;
    fn caption(&self) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn summary(&self) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
    fn nselected_rows(&self) -> Result<i32, dbus::MethodErr>;
    fn nselected_columns(&self) -> Result<i32, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_TABLE_NAME: &str = "org.a11y.atspi.Table";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiTableProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiTableProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.Table").map(Self)
    }

    pub fn nrows(&self) -> Option<i32> {
        arg::prop_cast(self.0, "NRows").copied()
    }

    pub fn ncolumns(&self) -> Option<i32> {
        arg::prop_cast(self.0, "NColumns").copied()
    }

    pub fn caption(&self) -> Option<&(String, dbus::Path<'static>)> {
        arg::prop_cast(self.0, "Caption")
    }

    pub fn summary(&self) -> Option<&(String, dbus::Path<'static>)> {
        arg::prop_cast(self.0, "Summary")
    }

    pub fn nselected_rows(&self) -> Option<i32> {
        arg::prop_cast(self.0, "NSelectedRows").copied()
    }

    pub fn nselected_columns(&self) -> Option<i32> {
        arg::prop_cast(self.0, "NSelectedColumns").copied()
    }
}

pub fn register_org_a11y_atspi_table<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiTable + Send + 'static,
{
    cr.register("org.a11y.atspi.Table", |b| {
        b.method(
            "GetAccessibleAt",
            ("row", "column"),
            ("",),
            |_, t: &mut T, (row, column)| t.get_accessible_at(row, column).map(|x| (x,)),
        );
        b.method(
            "GetIndexAt",
            ("row", "column"),
            ("",),
            |_, t: &mut T, (row, column)| t.get_index_at(row, column).map(|x| (x,)),
        );
        b.method(
            "GetRowAtIndex",
            ("index",),
            ("",),
            |_, t: &mut T, (index,)| t.get_row_at_index(index).map(|x| (x,)),
        );
        b.method(
            "GetColumnAtIndex",
            ("index",),
            ("",),
            |_, t: &mut T, (index,)| t.get_column_at_index(index).map(|x| (x,)),
        );
        b.method(
            "GetRowDescription",
            ("row",),
            ("",),
            |_, t: &mut T, (row,)| t.get_row_description(row).map(|x| (x,)),
        );
        b.method(
            "GetColumnDescription",
            ("column",),
            ("",),
            |_, t: &mut T, (column,)| t.get_column_description(column).map(|x| (x,)),
        );
        b.method(
            "GetRowExtentAt",
            ("row", "column"),
            ("",),
            |_, t: &mut T, (row, column)| t.get_row_extent_at(row, column).map(|x| (x,)),
        );
        b.method(
            "GetColumnExtentAt",
            ("row", "column"),
            ("",),
            |_, t: &mut T, (row, column)| t.get_column_extent_at(row, column).map(|x| (x,)),
        );
        b.method("GetRowHeader", ("row",), ("",), |_, t: &mut T, (row,)| {
            t.get_row_header(row).map(|x| (x,))
        });
        b.method(
            "GetColumnHeader",
            ("column",),
            ("",),
            |_, t: &mut T, (column,)| t.get_column_header(column).map(|x| (x,)),
        );
        b.method("GetSelectedRows", (), ("",), |_, t: &mut T, ()| {
            t.get_selected_rows().map(|x| (x,))
        });
        b.method("GetSelectedColumns", (), ("",), |_, t: &mut T, ()| {
            t.get_selected_columns().map(|x| (x,))
        });
        b.method("IsRowSelected", ("row",), ("",), |_, t: &mut T, (row,)| {
            t.is_row_selected(row).map(|x| (x,))
        });
        b.method(
            "IsColumnSelected",
            ("column",),
            ("",),
            |_, t: &mut T, (column,)| t.is_column_selected(column).map(|x| (x,)),
        );
        b.method(
            "IsSelected",
            ("row", "column"),
            ("",),
            |_, t: &mut T, (row, column)| t.is_selected(row, column).map(|x| (x,)),
        );
        b.method(
            "AddRowSelection",
            ("row",),
            ("",),
            |_, t: &mut T, (row,)| t.add_row_selection(row).map(|x| (x,)),
        );
        b.method(
            "AddColumnSelection",
            ("column",),
            ("",),
            |_, t: &mut T, (column,)| t.add_column_selection(column).map(|x| (x,)),
        );
        b.method(
            "RemoveRowSelection",
            ("row",),
            ("",),
            |_, t: &mut T, (row,)| t.remove_row_selection(row).map(|x| (x,)),
        );
        b.method(
            "RemoveColumnSelection",
            ("column",),
            ("",),
            |_, t: &mut T, (column,)| t.remove_column_selection(column).map(|x| (x,)),
        );
        b.method(
            "GetRowColumnExtentsAtIndex",
            ("index",),
            (
                "",
                "row",
                "col",
                "row_extents",
                "col_extents",
                "is_selected",
            ),
            |_, t: &mut T, (index,)| t.get_row_column_extents_at_index(index),
        );
        b.property::<i32, _>("NRows").get(|_, t| t.nrows());
        b.property::<i32, _>("NColumns").get(|_, t| t.ncolumns());
        b.property::<(String, dbus::Path<'static>), _>("Caption")
            .get(|_, t| t.caption());
        b.property::<(String, dbus::Path<'static>), _>("Summary")
            .get(|_, t| t.summary());
        b.property::<i32, _>("NSelectedRows")
            .get(|_, t| t.nselected_rows());
        b.property::<i32, _>("NSelectedColumns")
            .get(|_, t| t.nselected_columns());
    })
}

pub trait OrgA11yAtspiTableCell {
    fn get_row_column_span(&mut self) -> Result<(bool, i32, i32, i32, i32), dbus::MethodErr>;
    fn column_span(&self) -> Result<i32, dbus::MethodErr>;
    fn position(&self) -> Result<(i32, i32), dbus::MethodErr>;
    fn row_span(&self) -> Result<i32, dbus::MethodErr>;
    fn table(&self) -> Result<(String, dbus::Path<'static>), dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_TABLE_CELL_NAME: &str = "org.a11y.atspi.TableCell";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiTableCellProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiTableCellProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.TableCell").map(Self)
    }

    pub fn column_span(&self) -> Option<i32> {
        arg::prop_cast(self.0, "ColumnSpan").copied()
    }

    pub fn position(&self) -> Option<&(i32, i32)> {
        arg::prop_cast(self.0, "Position")
    }

    pub fn row_span(&self) -> Option<i32> {
        arg::prop_cast(self.0, "RowSpan").copied()
    }

    pub fn table(&self) -> Option<&(String, dbus::Path<'static>)> {
        arg::prop_cast(self.0, "Table")
    }
}

pub fn register_org_a11y_atspi_table_cell<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiTableCell + Send + 'static,
{
    cr.register("org.a11y.atspi.TableCell", |b| {
        b.method(
            "GetRowColumnSpan",
            (),
            ("", "row", "col", "row_extents", "col_extents"),
            |_, t: &mut T, ()| t.get_row_column_span(),
        );
        b.property::<i32, _>("ColumnSpan")
            .get(|_, t| t.column_span());
        b.property::<(i32, i32), _>("Position")
            .get(|_, t| t.position());
        b.property::<i32, _>("RowSpan").get(|_, t| t.row_span());
        b.property::<(String, dbus::Path<'static>), _>("Table")
            .get(|_, t| t.table());
    })
}

pub trait OrgA11yAtspiText {
    fn get_string_at_offset(
        &mut self,
        offset: i32,
        granularity: u32,
    ) -> Result<(String, i32, i32), dbus::MethodErr>;
    fn get_text(&mut self, start_offset: i32, end_offset: i32) -> Result<String, dbus::MethodErr>;
    fn set_caret_offset_(&mut self, offset: i32) -> Result<bool, dbus::MethodErr>;
    fn get_text_before_offset(
        &mut self,
        offset: i32,
        type_: u32,
    ) -> Result<(String, i32, i32), dbus::MethodErr>;
    fn get_text_at_offset(
        &mut self,
        offset: i32,
        type_: u32,
    ) -> Result<(String, i32, i32), dbus::MethodErr>;
    fn get_text_after_offset(
        &mut self,
        offset: i32,
        type_: u32,
    ) -> Result<(String, i32, i32), dbus::MethodErr>;
    fn get_character_at_offset(&mut self, offset: i32) -> Result<i32, dbus::MethodErr>;
    fn get_attribute_value(
        &mut self,
        offset: i32,
        attribute_name: String,
    ) -> Result<String, dbus::MethodErr>;
    fn get_attributes(
        &mut self,
        offset: i32,
    ) -> Result<(::std::collections::HashMap<String, String>, i32, i32), dbus::MethodErr>;
    fn get_default_attributes(
        &mut self,
    ) -> Result<::std::collections::HashMap<String, String>, dbus::MethodErr>;
    fn get_character_extents(
        &mut self,
        offset: i32,
        coord_type: u32,
    ) -> Result<(i32, i32, i32, i32), dbus::MethodErr>;
    fn get_offset_at_point(
        &mut self,
        x_: i32,
        y_: i32,
        coord_type: u32,
    ) -> Result<i32, dbus::MethodErr>;
    fn get_nselections(&mut self) -> Result<i32, dbus::MethodErr>;
    fn get_selection(&mut self, selection_num: i32) -> Result<(i32, i32), dbus::MethodErr>;
    fn add_selection(
        &mut self,
        start_offset: i32,
        end_offset: i32,
    ) -> Result<bool, dbus::MethodErr>;
    fn remove_selection(&mut self, selection_num: i32) -> Result<bool, dbus::MethodErr>;
    fn set_selection(
        &mut self,
        selection_num: i32,
        start_offset: i32,
        end_offset: i32,
    ) -> Result<bool, dbus::MethodErr>;
    fn get_range_extents(
        &mut self,
        start_offset: i32,
        end_offset: i32,
        coord_type: u32,
    ) -> Result<(i32, i32, i32, i32), dbus::MethodErr>;
    fn get_bounded_ranges(
        &mut self,
        x_: i32,
        y_: i32,
        width: i32,
        height: i32,
        coord_type: u32,
        x_clip_type: u32,
        y_clip_type: u32,
    ) -> Result<
        Vec<(
            i32,
            i32,
            String,
            arg::Variant<Box<dyn arg::RefArg + 'static>>,
        )>,
        dbus::MethodErr,
    >;
    fn get_attribute_run(
        &mut self,
        offset: i32,
        include_defaults: bool,
    ) -> Result<(::std::collections::HashMap<String, String>, i32, i32), dbus::MethodErr>;
    fn get_default_attribute_set(
        &mut self,
    ) -> Result<::std::collections::HashMap<String, String>, dbus::MethodErr>;
    fn scroll_substring_to(
        &mut self,
        start_offset: i32,
        end_offset: i32,
        type_: u32,
    ) -> Result<bool, dbus::MethodErr>;
    fn scroll_substring_to_point(
        &mut self,
        start_offset: i32,
        end_offset: i32,
        type_: u32,
        x_: i32,
        y_: i32,
    ) -> Result<bool, dbus::MethodErr>;
    fn character_count(&self) -> Result<i32, dbus::MethodErr>;
    fn caret_offset(&self) -> Result<i32, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_TEXT_NAME: &str = "org.a11y.atspi.Text";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiTextProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiTextProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.Text").map(Self)
    }

    pub fn character_count(&self) -> Option<i32> {
        arg::prop_cast(self.0, "CharacterCount").copied()
    }

    pub fn caret_offset(&self) -> Option<i32> {
        arg::prop_cast(self.0, "CaretOffset").copied()
    }
}

pub fn register_org_a11y_atspi_text<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiText + Send + 'static,
{
    cr.register("org.a11y.atspi.Text", |b| {
        b.method(
            "GetStringAtOffset",
            ("offset", "granularity"),
            ("", "startOffset", "endOffset"),
            |_, t: &mut T, (offset, granularity)| t.get_string_at_offset(offset, granularity),
        );
        b.method(
            "GetText",
            ("startOffset", "endOffset"),
            ("",),
            |_, t: &mut T, (startOffset, endOffset)| {
                t.get_text(startOffset, endOffset).map(|x| (x,))
            },
        );
        b.method(
            "SetCaretOffset",
            ("offset",),
            ("",),
            |_, t: &mut T, (offset,)| t.set_caret_offset_(offset).map(|x| (x,)),
        );
        b.method(
            "GetTextBeforeOffset",
            ("offset", "type"),
            ("", "startOffset", "endOffset"),
            |_, t: &mut T, (offset, r#type)| t.get_text_before_offset(offset, r#type),
        );
        b.method(
            "GetTextAtOffset",
            ("offset", "type"),
            ("", "startOffset", "endOffset"),
            |_, t: &mut T, (offset, r#type)| t.get_text_at_offset(offset, r#type),
        );
        b.method(
            "GetTextAfterOffset",
            ("offset", "type"),
            ("", "startOffset", "endOffset"),
            |_, t: &mut T, (offset, r#type)| t.get_text_after_offset(offset, r#type),
        );
        b.method(
            "GetCharacterAtOffset",
            ("offset",),
            ("",),
            |_, t: &mut T, (offset,)| t.get_character_at_offset(offset).map(|x| (x,)),
        );
        b.method(
            "GetAttributeValue",
            ("offset", "attributeName"),
            ("",),
            |_, t: &mut T, (offset, attributeName)| {
                t.get_attribute_value(offset, attributeName).map(|x| (x,))
            },
        );
        b.method(
            "GetAttributes",
            ("offset",),
            ("", "startOffset", "endOffset"),
            |_, t: &mut T, (offset,)| t.get_attributes(offset),
        );
        b.method("GetDefaultAttributes", (), ("",), |_, t: &mut T, ()| {
            t.get_default_attributes().map(|x| (x,))
        });
        b.method(
            "GetCharacterExtents",
            ("offset", "coordType"),
            ("x", "y", "width", "height"),
            |_, t: &mut T, (offset, coordType)| t.get_character_extents(offset, coordType),
        );
        b.method(
            "GetOffsetAtPoint",
            ("x", "y", "coordType"),
            ("",),
            |_, t: &mut T, (x, y, coordType)| t.get_offset_at_point(x, y, coordType).map(|x| (x,)),
        );
        b.method("GetNSelections", (), ("",), |_, t: &mut T, ()| {
            t.get_nselections().map(|x| (x,))
        });
        b.method(
            "GetSelection",
            ("selectionNum",),
            ("startOffset", "endOffset"),
            |_, t: &mut T, (selectionNum,)| t.get_selection(selectionNum),
        );
        b.method(
            "AddSelection",
            ("startOffset", "endOffset"),
            ("",),
            |_, t: &mut T, (startOffset, endOffset)| {
                t.add_selection(startOffset, endOffset).map(|x| (x,))
            },
        );
        b.method(
            "RemoveSelection",
            ("selectionNum",),
            ("",),
            |_, t: &mut T, (selectionNum,)| t.remove_selection(selectionNum).map(|x| (x,)),
        );
        b.method(
            "SetSelection",
            ("selectionNum", "startOffset", "endOffset"),
            ("",),
            |_, t: &mut T, (selectionNum, startOffset, endOffset)| {
                t.set_selection(selectionNum, startOffset, endOffset)
                    .map(|x| (x,))
            },
        );
        b.method(
            "GetRangeExtents",
            ("startOffset", "endOffset", "coordType"),
            ("x", "y", "width", "height"),
            |_, t: &mut T, (startOffset, endOffset, coordType)| {
                t.get_range_extents(startOffset, endOffset, coordType)
            },
        );
        b.method(
            "GetBoundedRanges",
            (
                "x",
                "y",
                "width",
                "height",
                "coordType",
                "xClipType",
                "yClipType",
            ),
            ("",),
            |_, t: &mut T, (x, y, width, height, coordType, xClipType, yClipType)| {
                t.get_bounded_ranges(x, y, width, height, coordType, xClipType, yClipType)
                    .map(|x| (x,))
            },
        );
        b.method(
            "GetAttributeRun",
            ("offset", "includeDefaults"),
            ("", "startOffset", "endOffset"),
            |_, t: &mut T, (offset, includeDefaults)| t.get_attribute_run(offset, includeDefaults),
        );
        b.method("GetDefaultAttributeSet", (), ("",), |_, t: &mut T, ()| {
            t.get_default_attribute_set().map(|x| (x,))
        });
        b.method(
            "ScrollSubstringTo",
            ("startOffset", "endOffset", "type"),
            ("",),
            |_, t: &mut T, (startOffset, endOffset, r#type)| {
                t.scroll_substring_to(startOffset, endOffset, r#type)
                    .map(|x| (x,))
            },
        );
        b.method(
            "ScrollSubstringToPoint",
            ("startOffset", "endOffset", "type", "x", "y"),
            ("",),
            |_, t: &mut T, (startOffset, endOffset, r#type, x, y)| {
                t.scroll_substring_to_point(startOffset, endOffset, r#type, x, y)
                    .map(|x| (x,))
            },
        );
        b.property::<i32, _>("CharacterCount")
            .get(|_, t| t.character_count());
        b.property::<i32, _>("CaretOffset")
            .get(|_, t| t.caret_offset());
    })
}

pub trait OrgA11yAtspiEditableText {
    fn set_text_contents(&mut self, new_contents: String) -> Result<bool, dbus::MethodErr>;
    fn insert_text(
        &mut self,
        position: i32,
        text: String,
        length: i32,
    ) -> Result<bool, dbus::MethodErr>;
    fn copy_text(&mut self, start_pos: i32, end_pos: i32) -> Result<(), dbus::MethodErr>;
    fn cut_text(&mut self, start_pos: i32, end_pos: i32) -> Result<bool, dbus::MethodErr>;
    fn delete_text(&mut self, start_pos: i32, end_pos: i32) -> Result<bool, dbus::MethodErr>;
    fn paste_text(&mut self, position: i32) -> Result<bool, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_EDITABLE_TEXT_NAME: &str = "org.a11y.atspi.EditableText";

pub fn register_org_a11y_atspi_editable_text<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiEditableText + Send + 'static,
{
    cr.register("org.a11y.atspi.EditableText", |b| {
        b.method(
            "SetTextContents",
            ("newContents",),
            ("",),
            |_, t: &mut T, (newContents,)| t.set_text_contents(newContents).map(|x| (x,)),
        );
        b.method(
            "InsertText",
            ("position", "text", "length"),
            ("",),
            |_, t: &mut T, (position, text, length)| {
                t.insert_text(position, text, length).map(|x| (x,))
            },
        );
        b.method(
            "CopyText",
            ("startPos", "endPos"),
            (),
            |_, t: &mut T, (startPos, endPos)| t.copy_text(startPos, endPos),
        );
        b.method(
            "CutText",
            ("startPos", "endPos"),
            ("",),
            |_, t: &mut T, (startPos, endPos)| t.cut_text(startPos, endPos).map(|x| (x,)),
        );
        b.method(
            "DeleteText",
            ("startPos", "endPos"),
            ("",),
            |_, t: &mut T, (startPos, endPos)| t.delete_text(startPos, endPos).map(|x| (x,)),
        );
        b.method(
            "PasteText",
            ("position",),
            ("",),
            |_, t: &mut T, (position,)| t.paste_text(position).map(|x| (x,)),
        );
    })
}

pub trait OrgA11yAtspiCache {
    fn get_items(
        &mut self,
    ) -> Result<
        Vec<(
            (String, dbus::Path<'static>),
            (String, dbus::Path<'static>),
            i32,
            i32,
            Vec<String>,
            String,
            u32,
            String,
            Vec<u32>,
        )>,
        dbus::MethodErr,
    >;
}

#[derive(Debug)]
pub struct OrgA11yAtspiCacheAddAccessible {
    pub node_added: (
        (String, dbus::Path<'static>),
        (String, dbus::Path<'static>),
        i32,
        i32,
        Vec<String>,
        String,
        u32,
        String,
        Vec<u32>,
    ),
}

impl arg::AppendAll for OrgA11yAtspiCacheAddAccessible {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.node_added, i);
    }
}

impl arg::ReadAll for OrgA11yAtspiCacheAddAccessible {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgA11yAtspiCacheAddAccessible {
            node_added: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgA11yAtspiCacheAddAccessible {
    const NAME: &'static str = "AddAccessible";
    const INTERFACE: &'static str = "org.a11y.atspi.Cache";
}

#[derive(Debug)]
pub struct OrgA11yAtspiCacheRemoveAccessible {
    pub node_removed: (String, dbus::Path<'static>),
}

impl arg::AppendAll for OrgA11yAtspiCacheRemoveAccessible {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.node_removed, i);
    }
}

impl arg::ReadAll for OrgA11yAtspiCacheRemoveAccessible {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgA11yAtspiCacheRemoveAccessible {
            node_removed: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgA11yAtspiCacheRemoveAccessible {
    const NAME: &'static str = "RemoveAccessible";
    const INTERFACE: &'static str = "org.a11y.atspi.Cache";
}

pub const ORG_A11Y_ATSPI_CACHE_NAME: &str = "org.a11y.atspi.Cache";

pub fn register_org_a11y_atspi_cache<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiCache + Send + 'static,
{
    cr.register("org.a11y.atspi.Cache", |b| {
        b.signal::<((
            (String, dbus::Path<'static>),
            (String, dbus::Path<'static>),
            i32,
            i32,
            Vec<String>,
            String,
            u32,
            String,
            Vec<u32>,
        ),), _>("AddAccessible", ("nodeAdded",));
        b.signal::<((String, dbus::Path<'static>),), _>("RemoveAccessible", ("nodeRemoved",));
        b.method("GetItems", (), ("nodes",), |_, t: &mut T, ()| {
            t.get_items().map(|x| (x,))
        });
    })
}

pub trait OrgA11yAtspiValue {
    fn minimum_value(&self) -> Result<f64, dbus::MethodErr>;
    fn maximum_value(&self) -> Result<f64, dbus::MethodErr>;
    fn minimum_increment(&self) -> Result<f64, dbus::MethodErr>;
    fn current_value(&self) -> Result<f64, dbus::MethodErr>;
    fn set_current_value(&self, value: f64) -> Result<(), dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_VALUE_NAME: &str = "org.a11y.atspi.Value";

#[derive(Copy, Clone, Debug)]
pub struct OrgA11yAtspiValueProperties<'a>(pub &'a arg::PropMap);

impl<'a> OrgA11yAtspiValueProperties<'a> {
    pub fn from_interfaces(
        interfaces: &'a ::std::collections::HashMap<String, arg::PropMap>,
    ) -> Option<Self> {
        interfaces.get("org.a11y.atspi.Value").map(Self)
    }

    pub fn minimum_value(&self) -> Option<f64> {
        arg::prop_cast(self.0, "MinimumValue").copied()
    }

    pub fn maximum_value(&self) -> Option<f64> {
        arg::prop_cast(self.0, "MaximumValue").copied()
    }

    pub fn minimum_increment(&self) -> Option<f64> {
        arg::prop_cast(self.0, "MinimumIncrement").copied()
    }

    pub fn current_value(&self) -> Option<f64> {
        arg::prop_cast(self.0, "CurrentValue").copied()
    }
}

pub fn register_org_a11y_atspi_value<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiValue + Send + 'static,
{
    cr.register("org.a11y.atspi.Value", |b: &mut IfaceBuilder<T>| {
        b.property::<f64, _>("MinimumValue")
            .get(|_, t| t.minimum_value());
        b.property::<f64, _>("MaximumValue")
            .get(|_, t| t.maximum_value());
        b.property::<f64, _>("MinimumIncrement")
            .get(|_, t| t.minimum_increment());
        b.property::<f64, _>("CurrentValue")
            .get(|_, t| t.current_value())
            .set(|_, t, value| t.set_current_value(value).map(|_| None));
    })
}

pub trait OrgA11yAtspiRegistry {
    fn register_event(&mut self, event: String) -> Result<(), dbus::MethodErr>;
    fn deregister_event(&mut self, event: String) -> Result<(), dbus::MethodErr>;
    fn get_registered_events(&mut self) -> Result<Vec<(String, String)>, dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgA11yAtspiRegistryEventListenerRegistered {
    pub bus: String,
    pub path: String,
}

impl arg::AppendAll for OrgA11yAtspiRegistryEventListenerRegistered {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.bus, i);
        arg::RefArg::append(&self.path, i);
    }
}

impl arg::ReadAll for OrgA11yAtspiRegistryEventListenerRegistered {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgA11yAtspiRegistryEventListenerRegistered {
            bus: i.read()?,
            path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgA11yAtspiRegistryEventListenerRegistered {
    const NAME: &'static str = "EventListenerRegistered";
    const INTERFACE: &'static str = "org.a11y.atspi.Registry";
}

#[derive(Debug)]
pub struct OrgA11yAtspiRegistryEventListenerDeregistered {
    pub bus: String,
    pub path: String,
}

impl arg::AppendAll for OrgA11yAtspiRegistryEventListenerDeregistered {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.bus, i);
        arg::RefArg::append(&self.path, i);
    }
}

impl arg::ReadAll for OrgA11yAtspiRegistryEventListenerDeregistered {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgA11yAtspiRegistryEventListenerDeregistered {
            bus: i.read()?,
            path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgA11yAtspiRegistryEventListenerDeregistered {
    const NAME: &'static str = "EventListenerDeregistered";
    const INTERFACE: &'static str = "org.a11y.atspi.Registry";
}

pub const ORG_A11Y_ATSPI_REGISTRY_NAME: &str = "org.a11y.atspi.Registry";

pub fn register_org_a11y_atspi_registry<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiRegistry + Send + 'static,
{
    cr.register("org.a11y.atspi.Registry", |b| {
        b.signal::<(String, String), _>("EventListenerRegistered", ("bus", "path"));
        b.signal::<(String, String), _>("EventListenerDeregistered", ("bus", "path"));
        b.method("RegisterEvent", ("event",), (), |_, t: &mut T, (event,)| {
            t.register_event(event)
        });
        b.method(
            "DeregisterEvent",
            ("event",),
            (),
            |_, t: &mut T, (event,)| t.deregister_event(event),
        );
        b.method(
            "GetRegisteredEvents",
            (),
            ("events",),
            |_, t: &mut T, ()| t.get_registered_events().map(|x| (x,)),
        );
    })
}

pub trait OrgA11yAtspiDeviceEventController {
    fn register_keystroke_listener(
        &mut self,
        listener: dbus::Path<'static>,
        keys: Vec<(i32, i32, String, i32)>,
        mask: u32,
        type_: Vec<u32>,
        mode: (bool, bool, bool),
    ) -> Result<bool, dbus::MethodErr>;
    fn deregister_keystroke_listener(
        &mut self,
        listener: dbus::Path<'static>,
        keys: Vec<(i32, i32, String, i32)>,
        mask: u32,
        type_: u32,
    ) -> Result<(), dbus::MethodErr>;
    fn register_device_event_listener(
        &mut self,
        listener: dbus::Path<'static>,
        types: u32,
    ) -> Result<bool, dbus::MethodErr>;
    fn deregister_device_event_listener(
        &mut self,
        listener: dbus::Path<'static>,
        types: u32,
    ) -> Result<(), dbus::MethodErr>;
    fn generate_keyboard_event(
        &mut self,
        keycode: i32,
        keystring: String,
        type_: u32,
    ) -> Result<(), dbus::MethodErr>;
    fn generate_mouse_event(
        &mut self,
        x_: i32,
        y_: i32,
        event_name: String,
    ) -> Result<(), dbus::MethodErr>;
    fn notify_listeners_sync(
        &mut self,
        event: (u32, i32, u32, u32, i32, String, bool),
    ) -> Result<bool, dbus::MethodErr>;
    fn notify_listeners_async(
        &mut self,
        event: (u32, i32, u32, u32, i32, String, bool),
    ) -> Result<(), dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_DEVICE_EVENT_CONTROLLER_NAME: &str =
    "org.a11y.atspi.DeviceEventController";

pub fn register_org_a11y_atspi_device_event_controller<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiDeviceEventController + Send + 'static,
{
    cr.register("org.a11y.atspi.DeviceEventController", |b| {
        b.method(
            "RegisterKeystrokeListener",
            ("listener", "keys", "mask", "type", "mode"),
            ("",),
            |_, t: &mut T, (listener, keys, mask, r#type, mode)| {
                t.register_keystroke_listener(listener, keys, mask, r#type, mode)
                    .map(|x| (x,))
            },
        );
        b.method(
            "DeregisterKeystrokeListener",
            ("listener", "keys", "mask", "type"),
            (),
            |_, t: &mut T, (listener, keys, mask, r#type)| {
                t.deregister_keystroke_listener(listener, keys, mask, r#type)
            },
        );
        b.method(
            "RegisterDeviceEventListener",
            ("listener", "types"),
            ("",),
            |_, t: &mut T, (listener, types)| {
                t.register_device_event_listener(listener, types)
                    .map(|x| (x,))
            },
        );
        b.method(
            "DeregisterDeviceEventListener",
            ("listener", "types"),
            (),
            |_, t: &mut T, (listener, types)| t.deregister_device_event_listener(listener, types),
        );
        b.method(
            "GenerateKeyboardEvent",
            ("keycode", "keystring", "type"),
            (),
            |_, t: &mut T, (keycode, keystring, r#type)| {
                t.generate_keyboard_event(keycode, keystring, r#type)
            },
        );
        b.method(
            "GenerateMouseEvent",
            ("x", "y", "eventName"),
            (),
            |_, t: &mut T, (x, y, eventName)| t.generate_mouse_event(x, y, eventName),
        );
        b.method(
            "NotifyListenersSync",
            ("event",),
            ("",),
            |_, t: &mut T, (event,)| t.notify_listeners_sync(event).map(|x| (x,)),
        );
        b.method(
            "NotifyListenersAsync",
            ("event",),
            (),
            |_, t: &mut T, (event,)| t.notify_listeners_async(event),
        );
    })
}

pub trait OrgA11yAtspiDeviceEventListener {
    fn notify_event(
        &mut self,
        event: (u32, i32, u32, u32, i32, String, bool),
    ) -> Result<bool, dbus::MethodErr>;
}

pub const ORG_A11Y_ATSPI_DEVICE_EVENT_LISTENER_NAME: &str = "org.a11y.atspi.DeviceEventListener";

pub fn register_org_a11y_atspi_device_event_listener<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgA11yAtspiDeviceEventListener + Send + 'static,
{
    cr.register("org.a11y.atspi.DeviceEventListener", |b| {
        b.method(
            "NotifyEvent",
            ("event",),
            ("",),
            |_, t: &mut T, (event,)| t.notify_event(event).map(|x| (x,)),
        );
    })
}
