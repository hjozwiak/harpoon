// Generated by gir (https://github.com/gtk-rs/gir @ f64f90a)
// from girs (@ 520ff74)
// DO NOT EDIT

use crate::KeyDefinition;
use glib::object::IsA;
use glib::translate::*;
use std::boxed::Box as Box_;
use std::fmt;

glib::wrapper! {
    #[doc(alias = "AtspiDevice")]
    pub struct Device(Object<ffi::AtspiDevice, ffi::AtspiDeviceClass>);

    match fn {
        type_ => || ffi::atspi_device_get_type(),
    }
}

impl Device {
    #[doc(alias = "atspi_device_new")]
    pub fn new() -> Device {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::atspi_device_new())
        }
    }
}

impl Default for Device {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_DEVICE: Option<&Device> = None;

pub trait DeviceExt: 'static {
    #[doc(alias = "atspi_device_add_key_grab")]
    fn add_key_grab(&self, kd: &mut KeyDefinition, callback: Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>>) -> u32;

    #[doc(alias = "atspi_device_add_key_watcher")]
    fn add_key_watcher(&self, callback: Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>>);

    #[doc(alias = "atspi_device_get_grab_by_id")]
    #[doc(alias = "get_grab_by_id")]
    fn grab_by_id(&self, id: u32) -> Option<KeyDefinition>;

    #[doc(alias = "atspi_device_get_locked_modifiers")]
    #[doc(alias = "get_locked_modifiers")]
    fn locked_modifiers(&self) -> u32;

    #[doc(alias = "atspi_device_get_modifier")]
    #[doc(alias = "get_modifier")]
    fn modifier(&self, keycode: i32) -> u32;

    #[doc(alias = "atspi_device_grab_keyboard")]
    fn grab_keyboard(&self) -> bool;

    #[doc(alias = "atspi_device_map_modifier")]
    fn map_modifier(&self, keycode: i32) -> u32;

    #[doc(alias = "atspi_device_notify_key")]
    fn notify_key(&self, pressed: bool, keycode: i32, keysym: i32, state: i32, text: &str) -> bool;

    #[doc(alias = "atspi_device_remove_key_grab")]
    fn remove_key_grab(&self, id: u32);

    #[doc(alias = "atspi_device_ungrab_keyboard")]
    fn ungrab_keyboard(&self);

    #[doc(alias = "atspi_device_unmap_modifier")]
    fn unmap_modifier(&self, keycode: i32);
}

impl<O: IsA<Device>> DeviceExt for O {
    fn add_key_grab(&self, kd: &mut KeyDefinition, callback: Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>>) -> u32 {
        let callback_data: Box_<Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>>> = Box_::new(callback);
        unsafe extern "C" fn callback_func(device: *mut ffi::AtspiDevice, pressed: glib::ffi::gboolean, keycode: libc::c_uint, keysym: libc::c_uint, modifiers: libc::c_uint, keystring: *const libc::c_char, user_data: glib::ffi::gpointer) {
            let device = from_glib_borrow(device);
            let pressed = from_glib(pressed);
            let keystring: Borrowed<glib::GString> = from_glib_borrow(keystring);
            let callback: &Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>> = &*(user_data as *mut _);
            if let Some(ref callback) = *callback {
                callback(&device, pressed, keycode, keysym, modifiers, keystring.as_str())
            } else {
                panic!("cannot get closure...")
            };
        }
        let callback = if callback_data.is_some() { Some(callback_func as _) } else { None };
        unsafe extern "C" fn callback_destroyed_func(data: glib::ffi::gpointer) {
            let _callback: Box_<Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>>> = Box_::from_raw(data as *mut _);
        }
        let destroy_call4 = Some(callback_destroyed_func as _);
        let super_callback0: Box_<Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>>> = callback_data;
        unsafe {
            ffi::atspi_device_add_key_grab(self.as_ref().to_glib_none().0, kd.to_glib_none_mut().0, callback, Box_::into_raw(super_callback0) as *mut _, destroy_call4)
        }
    }

    fn add_key_watcher(&self, callback: Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>>) {
        let callback_data: Box_<Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>>> = Box_::new(callback);
        unsafe extern "C" fn callback_func(device: *mut ffi::AtspiDevice, pressed: glib::ffi::gboolean, keycode: libc::c_uint, keysym: libc::c_uint, modifiers: libc::c_uint, keystring: *const libc::c_char, user_data: glib::ffi::gpointer) {
            let device = from_glib_borrow(device);
            let pressed = from_glib(pressed);
            let keystring: Borrowed<glib::GString> = from_glib_borrow(keystring);
            let callback: &Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>> = &*(user_data as *mut _);
            if let Some(ref callback) = *callback {
                callback(&device, pressed, keycode, keysym, modifiers, keystring.as_str())
            } else {
                panic!("cannot get closure...")
            };
        }
        let callback = if callback_data.is_some() { Some(callback_func as _) } else { None };
        unsafe extern "C" fn callback_destroyed_func(data: glib::ffi::gpointer) {
            let _callback: Box_<Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>>> = Box_::from_raw(data as *mut _);
        }
        let destroy_call3 = Some(callback_destroyed_func as _);
        let super_callback0: Box_<Option<Box_<dyn Fn(&Device, bool, u32, u32, u32, &str) + 'static>>> = callback_data;
        unsafe {
            ffi::atspi_device_add_key_watcher(self.as_ref().to_glib_none().0, callback, Box_::into_raw(super_callback0) as *mut _, destroy_call3);
        }
    }

    fn grab_by_id(&self, id: u32) -> Option<KeyDefinition> {
        unsafe {
            from_glib_full(ffi::atspi_device_get_grab_by_id(self.as_ref().to_glib_none().0, id))
        }
    }

    fn locked_modifiers(&self) -> u32 {
        unsafe {
            ffi::atspi_device_get_locked_modifiers(self.as_ref().to_glib_none().0)
        }
    }

    fn modifier(&self, keycode: i32) -> u32 {
        unsafe {
            ffi::atspi_device_get_modifier(self.as_ref().to_glib_none().0, keycode)
        }
    }

    fn grab_keyboard(&self) -> bool {
        unsafe {
            from_glib(ffi::atspi_device_grab_keyboard(self.as_ref().to_glib_none().0))
        }
    }

    fn map_modifier(&self, keycode: i32) -> u32 {
        unsafe {
            ffi::atspi_device_map_modifier(self.as_ref().to_glib_none().0, keycode)
        }
    }

    fn notify_key(&self, pressed: bool, keycode: i32, keysym: i32, state: i32, text: &str) -> bool {
        unsafe {
            from_glib(ffi::atspi_device_notify_key(self.as_ref().to_glib_none().0, pressed.into_glib(), keycode, keysym, state, text.to_glib_none().0))
        }
    }

    fn remove_key_grab(&self, id: u32) {
        unsafe {
            ffi::atspi_device_remove_key_grab(self.as_ref().to_glib_none().0, id);
        }
    }

    fn ungrab_keyboard(&self) {
        unsafe {
            ffi::atspi_device_ungrab_keyboard(self.as_ref().to_glib_none().0);
        }
    }

    fn unmap_modifier(&self, keycode: i32) {
        unsafe {
            ffi::atspi_device_unmap_modifier(self.as_ref().to_glib_none().0, keycode);
        }
    }
}

impl fmt::Display for Device {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Device")
    }
}
